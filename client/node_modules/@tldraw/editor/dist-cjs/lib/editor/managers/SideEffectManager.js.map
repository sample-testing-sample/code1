{
  "version": 3,
  "sources": ["../../../../src/lib/editor/managers/SideEffectManager.ts"],
  "sourcesContent": ["import { TLRecord, TLStore } from '@tldraw/tlschema'\n\n/** @public */\nexport type TLBeforeCreateHandler<R extends TLRecord> = (record: R, source: 'remote' | 'user') => R\n/** @public */\nexport type TLAfterCreateHandler<R extends TLRecord> = (\n\trecord: R,\n\tsource: 'remote' | 'user'\n) => void\n/** @public */\nexport type TLBeforeChangeHandler<R extends TLRecord> = (\n\tprev: R,\n\tnext: R,\n\tsource: 'remote' | 'user'\n) => R\n/** @public */\nexport type TLAfterChangeHandler<R extends TLRecord> = (\n\tprev: R,\n\tnext: R,\n\tsource: 'remote' | 'user'\n) => void\n/** @public */\nexport type TLBeforeDeleteHandler<R extends TLRecord> = (\n\trecord: R,\n\tsource: 'remote' | 'user'\n) => void | false\n/** @public */\nexport type TLAfterDeleteHandler<R extends TLRecord> = (\n\trecord: R,\n\tsource: 'remote' | 'user'\n) => void\n/** @public */\nexport type TLBatchCompleteHandler = () => void\n\n/**\n * The side effect manager (aka a \"correct state enforcer\") is responsible\n * for making sure that the editor's state is always correct. This includes\n * things like: deleting a shape if its parent is deleted; unbinding\n * arrows when their binding target is deleted; etc.\n *\n * @public\n */\nexport class SideEffectManager<\n\tCTX extends {\n\t\tstore: TLStore\n\t\thistory: { onBatchComplete: () => void }\n\t},\n> {\n\tconstructor(public editor: CTX) {\n\t\teditor.store.onBeforeCreate = (record, source) => {\n\t\t\tconst handlers = this._beforeCreateHandlers[\n\t\t\t\trecord.typeName\n\t\t\t] as TLBeforeCreateHandler<TLRecord>[]\n\t\t\tif (handlers) {\n\t\t\t\tlet r = record\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\tr = handler(r, source)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t}\n\n\t\t\treturn record\n\t\t}\n\n\t\teditor.store.onAfterCreate = (record, source) => {\n\t\t\tconst handlers = this._afterCreateHandlers[\n\t\t\t\trecord.typeName\n\t\t\t] as TLAfterCreateHandler<TLRecord>[]\n\t\t\tif (handlers) {\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\thandler(record, source)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\teditor.store.onBeforeChange = (prev, next, source) => {\n\t\t\tconst handlers = this._beforeChangeHandlers[\n\t\t\t\tnext.typeName\n\t\t\t] as TLBeforeChangeHandler<TLRecord>[]\n\t\t\tif (handlers) {\n\t\t\t\tlet r = next\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\tr = handler(prev, r, source)\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t}\n\n\t\t\treturn next\n\t\t}\n\n\t\tlet updateDepth = 0\n\n\t\teditor.store.onAfterChange = (prev, next, source) => {\n\t\t\tupdateDepth++\n\n\t\t\tif (updateDepth > 1000) {\n\t\t\t\tconsole.error('[CleanupManager.onAfterChange] Maximum update depth exceeded, bailing out.')\n\t\t\t} else {\n\t\t\t\tconst handlers = this._afterChangeHandlers[\n\t\t\t\t\tnext.typeName\n\t\t\t\t] as TLAfterChangeHandler<TLRecord>[]\n\t\t\t\tif (handlers) {\n\t\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\t\thandler(prev, next, source)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateDepth--\n\t\t}\n\n\t\teditor.store.onBeforeDelete = (record, source) => {\n\t\t\tconst handlers = this._beforeDeleteHandlers[\n\t\t\t\trecord.typeName\n\t\t\t] as TLBeforeDeleteHandler<TLRecord>[]\n\t\t\tif (handlers) {\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\tif (handler(record, source) === false) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\teditor.store.onAfterDelete = (record, source) => {\n\t\t\tconst handlers = this._afterDeleteHandlers[\n\t\t\t\trecord.typeName\n\t\t\t] as TLAfterDeleteHandler<TLRecord>[]\n\t\t\tif (handlers) {\n\t\t\t\tfor (const handler of handlers) {\n\t\t\t\t\thandler(record, source)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\teditor.history.onBatchComplete = () => {\n\t\t\tthis._batchCompleteHandlers.forEach((fn) => fn())\n\t\t}\n\t}\n\n\tprivate _beforeCreateHandlers: Partial<{\n\t\t[K in TLRecord['typeName']]: TLBeforeCreateHandler<TLRecord & { typeName: K }>[]\n\t}> = {}\n\tprivate _afterCreateHandlers: Partial<{\n\t\t[K in TLRecord['typeName']]: TLAfterCreateHandler<TLRecord & { typeName: K }>[]\n\t}> = {}\n\tprivate _beforeChangeHandlers: Partial<{\n\t\t[K in TLRecord['typeName']]: TLBeforeChangeHandler<TLRecord & { typeName: K }>[]\n\t}> = {}\n\tprivate _afterChangeHandlers: Partial<{\n\t\t[K in TLRecord['typeName']]: TLAfterChangeHandler<TLRecord & { typeName: K }>[]\n\t}> = {}\n\n\tprivate _beforeDeleteHandlers: Partial<{\n\t\t[K in TLRecord['typeName']]: TLBeforeDeleteHandler<TLRecord & { typeName: K }>[]\n\t}> = {}\n\n\tprivate _afterDeleteHandlers: Partial<{\n\t\t[K in TLRecord['typeName']]: TLAfterDeleteHandler<TLRecord & { typeName: K }>[]\n\t}> = {}\n\n\tprivate _batchCompleteHandlers: TLBatchCompleteHandler[] = []\n\n\t/**\n\t * Register a handler to be called before a record of a certain type is created. Return a\n\t * modified record from the handler to change the record that will be created.\n\t *\n\t * Use this handle only to modify the creation of the record itself. If you want to trigger a\n\t * side-effect on a different record (for example, moving one shape when another is created),\n\t * use {@link SideEffectManager.registerAfterCreateHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {\n\t *     // only modify shapes created by the user\n\t *     if (source !== 'user') return shape\n\t *\n\t *     //by default, arrow shapes have no label. Let's make sure they always have a label.\n\t *     if (shape.type === 'arrow') {\n\t *         return {...shape, props: {...shape.props, text: 'an arrow'}}\n\t *     }\n\t *\n\t *     // other shapes get returned unmodified\n\t *     return shape\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t */\n\tregisterBeforeCreateHandler<T extends TLRecord['typeName']>(\n\t\ttypeName: T,\n\t\thandler: TLBeforeCreateHandler<TLRecord & { typeName: T }>\n\t) {\n\t\tconst handlers = this._beforeCreateHandlers[typeName] as TLBeforeCreateHandler<any>[]\n\t\tif (!handlers) this._beforeCreateHandlers[typeName] = []\n\t\tthis._beforeCreateHandlers[typeName]!.push(handler)\n\t\treturn () => remove(this._beforeCreateHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called after a record is created. This is useful for side-effects\n\t * that would update _other_ records. If you want to modify the record being created use\n\t * {@link SideEffectManager.registerBeforeCreateHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {\n\t *     // Automatically create a shape when a page is created\n\t *     editor.createShape({\n\t *         id: createShapeId(),\n\t *         type: 'text',\n\t *         props: { text: page.name },\n\t *     })\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t */\n\tregisterAfterCreateHandler<T extends TLRecord['typeName']>(\n\t\ttypeName: T,\n\t\thandler: TLAfterCreateHandler<TLRecord & { typeName: T }>\n\t) {\n\t\tconst handlers = this._afterCreateHandlers[typeName] as TLAfterCreateHandler<any>[]\n\t\tif (!handlers) this._afterCreateHandlers[typeName] = []\n\t\tthis._afterCreateHandlers[typeName]!.push(handler)\n\t\treturn () => remove(this._afterCreateHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called before a record is changed. The handler is given the old and\n\t * new record - you can return a modified record to apply a different update, or the old record\n\t * to block the update entirely.\n\t *\n\t * Use this handler only for intercepting updates to the record itself. If you want to update\n\t * other records in response to a change, use\n\t * {@link SideEffectManager.registerAfterChangeHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {\n\t *     if (next.isLocked && !prev.isLocked) {\n\t *         // prevent shapes from ever being locked:\n\t *         return prev\n\t *     }\n\t *     // other types of change are allowed\n\t *     return next\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t */\n\tregisterBeforeChangeHandler<T extends TLRecord['typeName']>(\n\t\ttypeName: T,\n\t\thandler: TLBeforeChangeHandler<TLRecord & { typeName: T }>\n\t) {\n\t\tconst handlers = this._beforeChangeHandlers[typeName] as TLBeforeChangeHandler<any>[]\n\t\tif (!handlers) this._beforeChangeHandlers[typeName] = []\n\t\tthis._beforeChangeHandlers[typeName]!.push(handler)\n\t\treturn () => remove(this._beforeChangeHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called after a record is changed. This is useful for side-effects\n\t * that would update _other_ records - if you want to modify the record being changed, use\n\t * {@link SideEffectManager.registerBeforeChangeHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {\n\t *     if (next.props.color === 'red') {\n\t *         // there can only be one red shape at a time:\n\t *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)\n\t *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))\n\t *     }\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t */\n\tregisterAfterChangeHandler<T extends TLRecord['typeName']>(\n\t\ttypeName: T,\n\t\thandler: TLAfterChangeHandler<TLRecord & { typeName: T }>\n\t) {\n\t\tconst handlers = this._afterChangeHandlers[typeName] as TLAfterChangeHandler<any>[]\n\t\tif (!handlers) this._afterChangeHandlers[typeName] = []\n\t\tthis._afterChangeHandlers[typeName]!.push(handler as TLAfterChangeHandler<any>)\n\t\treturn () => remove(this._afterChangeHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called before a record is deleted. The handler can return `false` to\n\t * prevent the deletion.\n\t *\n\t * Use this handler only for intercepting deletions of the record itself. If you want to do\n\t * something to other records in response to a deletion, use\n\t * {@link SideEffectManager.registerAfterDeleteHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {\n\t *     if (shape.props.color === 'red') {\n\t *         // prevent red shapes from being deleted\n\t * \t       return false\n\t *     }\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t */\n\tregisterBeforeDeleteHandler<T extends TLRecord['typeName']>(\n\t\ttypeName: T,\n\t\thandler: TLBeforeDeleteHandler<TLRecord & { typeName: T }>\n\t) {\n\t\tconst handlers = this._beforeDeleteHandlers[typeName] as TLBeforeDeleteHandler<any>[]\n\t\tif (!handlers) this._beforeDeleteHandlers[typeName] = []\n\t\tthis._beforeDeleteHandlers[typeName]!.push(handler as TLBeforeDeleteHandler<any>)\n\t\treturn () => remove(this._beforeDeleteHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called after a record is deleted. This is useful for side-effects\n\t * that would update _other_ records - if you want to block the deletion of the record itself,\n\t * use {@link SideEffectManager.registerBeforeDeleteHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {\n\t *     // if the last shape in a frame is deleted, delete the frame too:\n\t *     const parentFrame = editor.getShape(shape.parentId)\n\t *     if (!parentFrame || parentFrame.type !== 'frame') return\n\t *\n\t *     const siblings = editor.getSortedChildIdsForParent(parentFrame)\n\t *     if (siblings.length === 0) {\n\t *         editor.deleteShape(parentFrame.id)\n\t *     }\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t */\n\tregisterAfterDeleteHandler<T extends TLRecord['typeName']>(\n\t\ttypeName: T,\n\t\thandler: TLAfterDeleteHandler<TLRecord & { typeName: T }>\n\t) {\n\t\tconst handlers = this._afterDeleteHandlers[typeName] as TLAfterDeleteHandler<any>[]\n\t\tif (!handlers) this._afterDeleteHandlers[typeName] = []\n\t\tthis._afterDeleteHandlers[typeName]!.push(handler as TLAfterDeleteHandler<any>)\n\t\treturn () => remove(this._afterDeleteHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called when a store completes a batch.\n\t *\n\t * @example\n\t * ```ts\n\t * let count = 0\n\t *\n\t * editor.cleanup.registerBatchCompleteHandler(() => count++)\n\t *\n\t * editor.selectAll()\n\t * expect(count).toBe(1)\n\t *\n\t * editor.batch(() => {\n\t *\teditor.selectNone()\n\t * \teditor.selectAll()\n\t * })\n\t *\n\t * expect(count).toBe(2)\n\t * ```\n\t *\n\t * @param handler - The handler to call\n\t *\n\t * @public\n\t */\n\tregisterBatchCompleteHandler(handler: TLBatchCompleteHandler) {\n\t\tthis._batchCompleteHandlers.push(handler)\n\t\treturn () => remove(this._batchCompleteHandlers, handler)\n\t}\n}\n\nfunction remove(array: any[], item: any) {\n\tconst index = array.indexOf(item)\n\tif (index >= 0) {\n\t\tarray.splice(index, 1)\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
