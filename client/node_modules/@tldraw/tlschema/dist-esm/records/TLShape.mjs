import {
  createMigrationIds,
  createMigrationSequence,
  createRecordMigrationSequence,
  createRecordType
} from "@tldraw/store";
import { assert, mapObjectMapValues } from "@tldraw/utils";
import { T } from "@tldraw/validate";
import { nanoid } from "nanoid";
import { createShapeValidator } from "../shapes/TLBaseShape.mjs";
import { StyleProp } from "../styles/StyleProp.mjs";
const rootShapeVersions = createMigrationIds("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
});
const rootShapeMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: rootShapeVersions.AddIsLocked,
      up: (record) => {
        record.isLocked = false;
      },
      down: (record) => {
        delete record.isLocked;
      }
    },
    {
      id: rootShapeVersions.HoistOpacity,
      up: (record) => {
        record.opacity = Number(record.props.opacity ?? "1");
        delete record.props.opacity;
      },
      down: (record) => {
        const opacity = record.opacity;
        delete record.opacity;
        record.props.opacity = opacity < 0.175 ? "0.1" : opacity < 0.375 ? "0.25" : opacity < 0.625 ? "0.5" : opacity < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: rootShapeVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: rootShapeVersions.AddWhite,
      up: (_record) => {
      },
      down: (record) => {
        if (record.props.color === "white") {
          record.props.color = "black";
        }
      }
    }
  ]
});
function isShape(record) {
  if (!record)
    return false;
  return record.typeName === "shape";
}
function isShapeId(id) {
  if (!id)
    return false;
  return id.startsWith("shape:");
}
function createShapeId(id) {
  return `shape:${id ?? nanoid()}`;
}
function getShapePropKeysByStyle(props) {
  const propKeysByStyle = /* @__PURE__ */ new Map();
  for (const [key, prop] of Object.entries(props)) {
    if (prop instanceof StyleProp) {
      if (propKeysByStyle.has(prop)) {
        throw new Error(
          `Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`
        );
      }
      propKeysByStyle.set(prop, key);
    }
  }
  return propKeysByStyle;
}
const NO_DOWN_MIGRATION = "none";
const RETIRED_DOWN_MIGRATION = "retired";
function createShapePropsMigrationSequence(migrations) {
  return migrations;
}
function createShapePropsMigrationIds(shapeType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`);
}
function processShapeMigrations(shapes) {
  const result = [];
  for (const [shapeType, { migrations }] of Object.entries(shapes)) {
    const sequenceId = `com.tldraw.shape.${shapeType}`;
    if (!migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: false,
          sequence: []
        })
      );
    } else if ("sequenceId" in migrations) {
      assert(
        sequenceId === migrations.sequenceId,
        `sequenceId mismatch for ${shapeType} shape migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`
      );
      result.push(migrations);
    } else if ("sequence" in migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: false,
          sequence: migrations.sequence.map(
            (m) => "id" in m ? {
              id: m.id,
              scope: "record",
              filter: (r) => r.typeName === "shape" && r.type === shapeType,
              dependsOn: m.dependsOn,
              up: (record) => {
                const result2 = m.up(record.props);
                if (result2) {
                  record.props = result2;
                }
              },
              down: typeof m.down === "function" ? (record) => {
                const result2 = m.down(record.props);
                if (result2) {
                  record.props = result2;
                }
              } : void 0
            } : m
          )
        })
      );
    } else {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: false,
          sequence: Object.keys(migrations.migrators).map((k) => Number(k)).sort((a, b) => a - b).map(
            (version) => ({
              id: `${sequenceId}/${version}`,
              scope: "record",
              filter: (r) => r.typeName === "shape" && r.type === shapeType,
              up: (record) => {
                const result2 = migrations.migrators[version].up(record);
                if (result2) {
                  return result2;
                }
              },
              down: (record) => {
                const result2 = migrations.migrators[version].down(record);
                if (result2) {
                  return result2;
                }
              }
            })
          )
        })
      );
    }
  }
  return result;
}
function createShapeRecordType(shapes) {
  return createRecordType("shape", {
    scope: "document",
    validator: T.model(
      "shape",
      T.union(
        "type",
        mapObjectMapValues(
          shapes,
          (type, { props, meta }) => createShapeValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: false,
    opacity: 1,
    meta: {}
  }));
}
export {
  NO_DOWN_MIGRATION,
  RETIRED_DOWN_MIGRATION,
  createShapeId,
  createShapePropsMigrationIds,
  createShapePropsMigrationSequence,
  createShapeRecordType,
  getShapePropKeysByStyle,
  isShape,
  isShapeId,
  processShapeMigrations,
  rootShapeMigrations,
  rootShapeVersions
};
//# sourceMappingURL=TLShape.mjs.map
