/// <reference types="react" />

import { ArrayOfValidator } from '@tldraw/editor';
import { BaseBoxShapeTool } from '@tldraw/editor';
import { BaseBoxShapeUtil } from '@tldraw/editor';
import { BoundsSnapPoint } from '@tldraw/editor';
import { Box } from '@tldraw/editor';
import { Circle2d } from '@tldraw/editor';
import { ComponentType } from 'react';
import { CubicSpline2d } from '@tldraw/editor';
import { DictValidator } from '@tldraw/editor';
import { Editor } from '@tldraw/editor';
import { EMBED_DEFINITIONS } from '@tldraw/editor';
import { EmbedDefinition } from '@tldraw/editor';
import { EnumStyleProp } from '@tldraw/editor';
import { Expand } from '@tldraw/editor';
import { Geometry2d } from '@tldraw/editor';
import { Group2d } from '@tldraw/editor';
import { HandleSnapGeometry } from '@tldraw/editor';
import { IndexKey } from '@tldraw/editor';
import { JsonObject } from '@tldraw/editor';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import { LANGUAGES } from '@tldraw/editor';
import { Mat } from '@tldraw/editor';
import { MatModel } from '@tldraw/editor';
import { MemoExoticComponent } from 'react';
import { MigrationFailureReason } from '@tldraw/editor';
import { MigrationSequence } from '@tldraw/editor';
import { NamedExoticComponent } from 'react';
import { ObjectValidator } from '@tldraw/editor';
import { Polygon2d } from '@tldraw/editor';
import { Polyline2d } from '@tldraw/editor';
import { default as React_2 } from 'react';
import * as React_3 from 'react';
import { ReactNode } from 'react';
import { ReadonlySharedStyleMap } from '@tldraw/editor';
import { Rectangle2d } from '@tldraw/editor';
import { RecursivePartial } from '@tldraw/editor';
import { Result } from '@tldraw/editor';
import { SelectionCorner } from '@tldraw/editor';
import { SelectionEdge } from '@tldraw/editor';
import { SelectionHandle } from '@tldraw/editor';
import { SerializedSchema } from '@tldraw/editor';
import { ShapeUtil } from '@tldraw/editor';
import { SharedStyle } from '@tldraw/editor';
import { StateNode } from '@tldraw/editor';
import { StoreSnapshot } from '@tldraw/editor';
import { StyleProp } from '@tldraw/editor';
import { SvgExportContext } from '@tldraw/editor';
import { T } from '@tldraw/editor';
import { TLAnyShapeUtilConstructor } from '@tldraw/editor';
import { TLArrowShape } from '@tldraw/editor';
import { TLAssetId } from '@tldraw/editor';
import { TLBaseEventInfo } from '@tldraw/editor';
import { TLBookmarkShape } from '@tldraw/editor';
import { TLCancelEvent } from '@tldraw/editor';
import { TLClickEvent } from '@tldraw/editor';
import { TLClickEventInfo } from '@tldraw/editor';
import { TLDefaultColorTheme } from '@tldraw/editor';
import { TLDefaultColorThemeColor } from '@tldraw/editor';
import { TLDefaultDashStyle } from '@tldraw/editor';
import { TLDefaultFillStyle } from '@tldraw/editor';
import { TLDefaultFontStyle } from '@tldraw/editor';
import { TLDefaultHorizontalAlignStyle } from '@tldraw/editor';
import { TLDefaultSizeStyle } from '@tldraw/editor';
import { TLDefaultVerticalAlignStyle } from '@tldraw/editor';
import { TldrawEditorBaseProps } from '@tldraw/editor';
import { TLDrawShape } from '@tldraw/editor';
import { TLDrawShapeSegment } from '@tldraw/editor';
import { TLEditorComponents } from '@tldraw/editor';
import { TLEmbedShape } from '@tldraw/editor';
import { TLEnterEventHandler } from '@tldraw/editor';
import { TLEventHandlers } from '@tldraw/editor';
import { TLExitEventHandler } from '@tldraw/editor';
import { TLFrameShape } from '@tldraw/editor';
import { TLGeoShape } from '@tldraw/editor';
import { TLHandle } from '@tldraw/editor';
import { TLHandlesProps } from '@tldraw/editor';
import { TLHighlightShape } from '@tldraw/editor';
import { TLImageShape } from '@tldraw/editor';
import { TLInterruptEvent } from '@tldraw/editor';
import { TLKeyboardEvent } from '@tldraw/editor';
import { TLKeyboardEventInfo } from '@tldraw/editor';
import { TLLineShape } from '@tldraw/editor';
import { TLNoteShape } from '@tldraw/editor';
import { TLOnBeforeCreateHandler } from '@tldraw/editor';
import { TLOnBeforeUpdateHandler } from '@tldraw/editor';
import { TLOnDoubleClickHandler } from '@tldraw/editor';
import { TLOnEditEndHandler } from '@tldraw/editor';
import { TLOnHandleDragHandler } from '@tldraw/editor';
import { TLOnResizeHandler } from '@tldraw/editor';
import { TLOnTranslateHandler } from '@tldraw/editor';
import { TLOnTranslateStartHandler } from '@tldraw/editor';
import { TLPageId } from '@tldraw/editor';
import { TLParentId } from '@tldraw/editor';
import { TLPointerEvent } from '@tldraw/editor';
import { TLPointerEventInfo } from '@tldraw/editor';
import { TLPointerEventName } from '@tldraw/editor';
import { TLRecord } from '@tldraw/editor';
import { TLRotationSnapshot } from '@tldraw/editor';
import { TLSchema } from '@tldraw/editor';
import { TLScribbleProps } from '@tldraw/editor';
import { TLSelectionBackgroundProps } from '@tldraw/editor';
import { TLSelectionForegroundProps } from '@tldraw/editor';
import { TLSelectionHandle } from '@tldraw/editor';
import { TLShape } from '@tldraw/editor';
import { TLShapeId } from '@tldraw/editor';
import { TLShapePartial } from '@tldraw/editor';
import { TLShapePropsMigrations } from '@tldraw/editor';
import { TLShapeUtilCanvasSvgDef } from '@tldraw/editor';
import { TLShapeUtilFlag } from '@tldraw/editor';
import { TLStore } from '@tldraw/editor';
import { TLStoreWithStatus } from '@tldraw/editor';
import { TLSvgOptions } from '@tldraw/editor';
import { TLTextShape } from '@tldraw/editor';
import { TLUnknownShape } from '@tldraw/editor';
import { TLVideoShape } from '@tldraw/editor';
import { UnionValidator } from '@tldraw/editor';
import { UnknownRecord } from '@tldraw/editor';
import { Validator } from '@tldraw/editor';
import { Vec } from '@tldraw/editor';
import { VecLike } from '@tldraw/editor';
import { VecModel } from '@tldraw/editor';

/** @public */
declare type ActionsProviderProps = {
    children: React_3.ReactNode;
    overrides?: (editor: Editor, actions: TLUiActionsContextType, helpers: undefined) => TLUiActionsContextType;
};

/** @public */
export declare type AlertSeverity = 'error' | 'info' | 'success' | 'warning';

/** @public */
export declare function AlignMenuItems(): JSX_2.Element;

declare enum AlignStyle {
    Start = "start",
    Middle = "middle",
    End = "end",
    Justify = "justify"
}

/** @public */
export declare function ArrangeMenuSubmenu(): JSX_2.Element | null;

declare interface ArrowBinding extends TLV1Binding {
    handleId: keyof ArrowShape['handles'];
    distance: number;
    point: number[];
}

/** @public */
export declare function ArrowDownToolbarItem(): JSX_2.Element;

/** @public */
export declare function ArrowheadStylePickerSet({ styles }: {
    styles: ReadonlySharedStyleMap;
}): JSX_2.Element | null;

/** @public */
export declare function ArrowLeftToolbarItem(): JSX_2.Element;

/** @public */
export declare function ArrowRightToolbarItem(): JSX_2.Element;

declare interface ArrowShape extends TDBaseShape {
    type: TDShapeType.Arrow;
    bend: number;
    handles: {
        bend: TDHandle;
        end: TDHandle;
        start: TDHandle;
    };
    decorations?: {
        end?: Decoration;
        middle?: Decoration;
        start?: Decoration;
    };
    label?: string;
    labelPoint?: number[];
}

/** @public */
export declare class ArrowShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle | typeof Pointing)[];
    shapeType: string;
}

/** @public */
export declare class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
    static type: "arrow";
    static props: {
        arrowheadEnd: EnumStyleProp<"arrow" | "bar" | "diamond" | "dot" | "inverted" | "none" | "pipe" | "square" | "triangle">;
        arrowheadStart: EnumStyleProp<"arrow" | "bar" | "diamond" | "dot" | "inverted" | "none" | "pipe" | "square" | "triangle">;
        bend: Validator<number>;
        color: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        dash: EnumStyleProp<"dashed" | "dotted" | "draw" | "solid">;
        end: UnionValidator<"type", {
        binding: ObjectValidator<    {
        boundShapeId: TLShapeId;
        isExact: boolean;
        isPrecise: boolean;
        normalizedAnchor: VecModel;
        type: "binding";
        }>;
        point: ObjectValidator<    {
        type: "point";
        x: number;
        y: number;
        }>;
        }, never>;
        fill: EnumStyleProp<"none" | "pattern" | "semi" | "solid">;
        font: EnumStyleProp<"draw" | "mono" | "sans" | "serif">;
        labelColor: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        labelPosition: Validator<number>;
        size: EnumStyleProp<"l" | "m" | "s" | "xl">;
        start: UnionValidator<"type", {
        binding: ObjectValidator<    {
        boundShapeId: TLShapeId;
        isExact: boolean;
        isPrecise: boolean;
        normalizedAnchor: VecModel;
        type: "binding";
        }>;
        point: ObjectValidator<    {
        type: "point";
        x: number;
        y: number;
        }>;
        }, never>;
        text: Validator<string>;
    };
    static migrations: TLShapePropsMigrations;
    canEdit: () => boolean;
    canBind: () => boolean;
    canSnap: () => boolean;
    hideResizeHandles: TLShapeUtilFlag<TLArrowShape>;
    hideRotateHandle: TLShapeUtilFlag<TLArrowShape>;
    hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape>;
    hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape>;
    getDefaultProps(): TLArrowShape['props'];
    getGeometry(shape: TLArrowShape): Group2d;
    getHandles(shape: TLArrowShape): TLHandle[];
    onHandleDrag: TLOnHandleDragHandler<TLArrowShape>;
    onTranslateStart: TLOnTranslateStartHandler<TLArrowShape>;
    onTranslate?: TLOnTranslateHandler<TLArrowShape>;
    onResize: TLOnResizeHandler<TLArrowShape>;
    onDoubleClickHandle: (shape: TLArrowShape, handle: TLHandle) => TLShapePartial<TLArrowShape> | void;
    component(shape: TLArrowShape): JSX_2.Element | null;
    indicator(shape: TLArrowShape): JSX_2.Element | null;
    onEditEnd: TLOnEditEndHandler<TLArrowShape>;
    toSvg(shape: TLArrowShape, ctx: SvgExportContext): JSX_2.Element;
    getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[];
}

/** @public */
export declare function ArrowToolbarItem(): JSX_2.Element;

/** @public */
export declare function ArrowUpToolbarItem(): JSX_2.Element;

/** @public */
export declare function AssetToolbarItem(): JSX_2.Element;

/* Excluded from this release type: AssetUrlsProvider */

declare interface BaseTLUiComponents {
    ContextMenu: ComponentType<TLUiContextMenuProps>;
    ActionsMenu: ComponentType<TLUiActionsMenuProps>;
    HelpMenu: ComponentType<TLUiHelpMenuProps>;
    ZoomMenu: ComponentType<TLUiZoomMenuProps>;
    MainMenu: ComponentType<TLUiMainMenuProps>;
    Minimap: ComponentType;
    StylePanel: ComponentType<TLUiStylePanelProps>;
    PageMenu: ComponentType;
    NavigationPanel: ComponentType;
    Toolbar: ComponentType;
    KeyboardShortcutsDialog: ComponentType<TLUiKeyboardShortcutsDialogProps>;
    QuickActions: ComponentType<TLUiQuickActionsProps>;
    HelperButtons: ComponentType<TLUiHelperButtonsProps>;
    DebugPanel: ComponentType;
    DebugMenu: ComponentType;
    MenuPanel: ComponentType;
    TopPanel: ComponentType;
    SharePanel: ComponentType;
}

/** @public */
export declare class BookmarkShapeUtil extends BaseBoxShapeUtil<TLBookmarkShape> {
    static type: "bookmark";
    static props: {
        assetId: T.Validator<null | TLAssetId>;
        h: T.Validator<number>;
        url: T.Validator<string>;
        w: T.Validator<number>;
    };
    static migrations: TLShapePropsMigrations;
    canResize: () => boolean;
    hideSelectionBoundsFg: () => boolean;
    getDefaultProps(): TLBookmarkShape['props'];
    component(shape: TLBookmarkShape): JSX_2.Element;
    indicator(shape: TLBookmarkShape): JSX_2.Element;
    onBeforeCreate?: TLOnBeforeCreateHandler<TLBookmarkShape>;
    onBeforeUpdate?: TLOnBeforeUpdateHandler<TLBookmarkShape>;
}

declare type BoxWidthHeight = {
    h: number;
    w: number;
};

/** @public */
export declare function BreakPointProvider({ forceMobile, children, }: {
    children: ReactNode;
    forceMobile?: boolean;
}): JSX_2.Element;

declare class Brushing extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        shape?: undefined;
        target: "canvas";
    } & {
        target: 'canvas';
    };
    initialSelectedShapeIds: TLShapeId[];
    excludedShapeIds: Set<TLShapeId>;
    isWrapMode: boolean;
    initialStartShape: null | TLShape;
    onEnter: (info: TLPointerEventInfo & {
        target: 'canvas';
    }) => void;
    onExit: () => void;
    onTick: () => void;
    onPointerMove: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel?: TLCancelEvent | undefined;
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyUp?: TLKeyboardEvent | undefined;
    private complete;
    private hitTestShapes;
    onInterrupt: TLInterruptEvent;
    private handleHit;
}

/* Excluded from this release type: buildFromV1Document */

/** @public */
export declare function CheckBoxToolbarItem(): JSX_2.Element;

/** @public */
export declare function ClipboardMenuGroup(): JSX_2.Element;

/** @public */
export declare function CloudToolbarItem(): JSX_2.Element;

declare enum ColorStyle {
    White = "white",
    LightGray = "lightGray",
    Gray = "gray",
    Black = "black",
    Green = "green",
    Cyan = "cyan",
    Blue = "blue",
    Indigo = "indigo",
    Violet = "violet",
    Red = "red",
    Orange = "orange",
    Yellow = "yellow"
}

/** @public */
export declare function CommonStylePickerSet({ styles, theme, }: {
    styles: ReadonlySharedStyleMap;
    theme: TLDefaultColorTheme;
}): JSX_2.Element;

/**
 * Contains the size within the given box size
 *
 * @param originalSize - The size of the asset
 * @param containBoxSize - The container size
 * @returns Adjusted size
 * @public
 */
export declare function containBoxSize(originalSize: BoxWidthHeight, containBoxSize: BoxWidthHeight): BoxWidthHeight;

/** @public */
export declare function ConversionsMenuGroup(): JSX_2.Element | null;

/** @public */
export declare function ConvertToBookmarkMenuItem(): JSX_2.Element | null;

/** @public */
export declare function ConvertToEmbedMenuItem(): JSX_2.Element | null;

/**
 * Copy the given shapes to the clipboard.
 *
 * @param editor - The editor instance.
 * @param ids - The ids of the shapes to copy.
 * @param format - The format to copy as.
 * @param opts - Options for the copy.
 *
 * @public
 */
export declare function copyAs(editor: Editor, ids: TLShapeId[], format?: TLCopyType, opts?: Partial<TLSvgOptions>): Promise<void>;

/** @public */
export declare function CopyAsMenuGroup(): JSX_2.Element;

/** @public */
export declare function CopyMenuItem(): JSX_2.Element;

declare class Crop extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_10 | typeof PointingCrop | typeof TranslatingCrop)[];
}

declare class Cropping extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
        target: "selection";
    } & {
        handle: SelectionHandle;
        onInteractionEnd?: string | undefined;
        target: 'selection';
    };
    markId: string;
    private snapshot;
    onEnter: TLEnterEventHandler;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    private updateCursor;
    private getDefaultCrop;
    private updateShapes;
    private complete;
    private cancel;
    private createSnapshot;
}

/** @public */
export declare function CutMenuItem(): JSX_2.Element;

declare enum DashStyle {
    Draw = "draw",
    Solid = "solid",
    Dashed = "dashed",
    Dotted = "dotted"
}

/** @public */
export declare function DebugFlags(): JSX_2.Element | null;

declare enum Decoration {
    Arrow = "arrow"
}

/** @public */
export declare const DEFAULT_ACCEPTED_IMG_TYPE: string[];

/** @public */
export declare const DEFAULT_ACCEPTED_VID_TYPE: string[];

/** @public */
export declare const DefaultActionsMenu: NamedExoticComponent<TLUiActionsMenuProps>;

/** @public */
export declare function DefaultActionsMenuContent(): JSX_2.Element;

/** @public */
declare const DefaultContextMenu: NamedExoticComponent<TLUiContextMenuProps>;
export { DefaultContextMenu as ContextMenu }
export { DefaultContextMenu }

/** @public */
export declare function DefaultContextMenuContent(): JSX_2.Element | null;

/** @public */
export declare function DefaultDebugMenu({ children }: TLUiDebugMenuProps): JSX_2.Element;

/** @public */
export declare function DefaultDebugMenuContent(): JSX_2.Element;

/** @public */
export declare let defaultEditorAssetUrls: TLEditorAssetUrls;

/** @public */
export declare function DefaultHelperButtons({ children }: TLUiHelperButtonsProps): JSX_2.Element;

/** @public */
export declare function DefaultHelperButtonsContent(): JSX_2.Element;

declare type DefaultHelpers = ReturnType<typeof useDefaultHelpers>;

/** @public */
export declare const DefaultHelpMenu: NamedExoticComponent<TLUiHelpMenuProps>;

/** @public */
export declare function DefaultHelpMenuContent(): JSX_2.Element;

/** @public */
export declare const DefaultKeyboardShortcutsDialog: NamedExoticComponent<TLUiKeyboardShortcutsDialogProps>;

/** @public */
export declare function DefaultKeyboardShortcutsDialogContent(): JSX_2.Element;

/** @public */
export declare const DefaultMainMenu: NamedExoticComponent<TLUiMainMenuProps>;

/** @public */
export declare function DefaultMainMenuContent(): JSX_2.Element;

/** @public */
export declare function DefaultMinimap(): JSX_2.Element;

/** @public */
export declare const DefaultPageMenu: NamedExoticComponent<object>;

/** @public */
export declare const DefaultQuickActions: NamedExoticComponent<TLUiQuickActionsProps>;

/** @public */
export declare function DefaultQuickActionsContent(): JSX_2.Element | undefined;

/** @public */
export declare const defaultShapeTools: (typeof ArrowShapeTool | typeof DrawShapeTool | typeof FrameShapeTool | typeof GeoShapeTool | typeof LineShapeTool | typeof NoteShapeTool | typeof TextShapeTool)[];

/** @public */
export declare const defaultShapeUtils: TLAnyShapeUtilConstructor[];

/** @public */
export declare const DefaultStylePanel: NamedExoticComponent<TLUiStylePanelProps>;

/** @public */
export declare function DefaultStylePanelContent({ styles }: TLUiStylePanelContentProps): JSX_2.Element | null;

/**
 * The default toolbar for the editor. `children` defaults to the `DefaultToolbarContent` component.
 * Depending on the screen size, the children will overflow into a drop-down menu, with the most
 * recently active item from the overflow being shown in the main toolbar.
 *
 * @public
 */
export declare const DefaultToolbar: NamedExoticComponent<    {
children?: ReactNode;
}>;

/** @public */
export declare function DefaultToolbarContent(): JSX_2.Element;

/** @public */
export declare const defaultTools: (typeof EraserTool | typeof HandTool | typeof LaserTool | typeof SelectTool | typeof ZoomTool)[];

/** @public */
export declare const DefaultZoomMenu: NamedExoticComponent<TLUiZoomMenuProps>;

/** @public */
export declare function DefaultZoomMenuContent(): JSX_2.Element;

/** @public */
export declare function DeleteMenuItem(): JSX_2.Element;

/** @public */
export declare function DiamondToolbarItem(): JSX_2.Element;

/** @public */
export declare function DistributeMenuItems(): JSX_2.Element;

/**
 * Resize an image Blob to be smaller than it is currently.
 *
 * @example
 * ```ts
 * const image = await (await fetch('/image.jpg')).blob()
 * const size = await getImageSize(image)
 * const resizedImage = await downsizeImage(image, size.w / 2, size.h / 2, { type: "image/jpeg", quality: 0.92 })
 * ```
 *
 * @param image - The image Blob.
 * @param width - The desired width.
 * @param height - The desired height.
 * @param opts - Options for the image.
 * @public
 */
export declare function downsizeImage(blob: Blob, width: number, height: number, opts?: {
    quality?: number | undefined;
    type?: string | undefined;
}): Promise<Blob>;

/** @public */
declare class DragAndDropManager {
    editor: Editor;
    constructor(editor: Editor);
    prevDroppingShapeId: null | TLShapeId;
    droppingNodeTimer: null | ReturnType<typeof setTimeout>;
    first: boolean;
    updateDroppingNode(movingShapes: TLShape[], cb: () => void): void;
    private setDragTimer;
    private handleDrag;
    hintParents(movingShapes: TLShape[]): void;
    dropShapes(shapes: TLShape[]): void;
    clear(): void;
    dispose: () => void;
}

declare class Dragging extends StateNode {
    static id: string;
    initialCamera: Vec;
    onEnter: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: () => void;
    private update;
    private complete;
}

declare class DraggingHandle extends StateNode {
    static id: string;
    shapeId: TLShapeId;
    initialHandle: TLHandle;
    initialAdjacentHandle: null | TLHandle;
    initialPagePoint: Vec;
    markId: string;
    initialPageTransform: any;
    initialPageRotation: any;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        handle: TLHandle;
        shape: TLShape;
        target: "handle";
    } & {
        isCreating: boolean;
        onInteractionEnd?: string | undefined;
        shape: TLArrowShape | TLLineShape;
        target: 'handle';
    };
    isPrecise: boolean;
    isPreciseId: null | TLShapeId;
    pointingId: null | TLShapeId;
    onEnter: TLEnterEventHandler;
    private exactTimeout;
    private resetExactTimeout;
    private clearExactTimeout;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onKeyDown: TLKeyboardEvent | undefined;
    onKeyUp: TLKeyboardEvent | undefined;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLCancelEvent;
    onExit: () => void;
    private complete;
    private cancel;
    private update;
}

declare type DrawableShape = TLDrawShape | TLHighlightShape;

declare class Drawing extends StateNode {
    static id: string;
    info: TLPointerEventInfo;
    initialShape?: DrawableShape;
    shapeType: "draw" | "highlight";
    util: ShapeUtil<TLUnknownShape>;
    isPen: boolean;
    segmentMode: "free" | "starting_free" | "starting_straight" | "straight";
    didJustShiftClickToExtendPreviousShapeLine: boolean;
    pagePointWhereCurrentSegmentChanged: Vec;
    pagePointWhereNextSegmentChanged: null | Vec;
    lastRecordedPoint: Vec;
    mergeNextPoint: boolean;
    currentLineLength: number;
    canDraw: boolean;
    markId: null | string;
    onEnter: (info: TLPointerEventInfo) => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyUp: TLEventHandlers['onKeyUp'];
    onExit?: (() => void) | undefined;
    canClose(): boolean;
    getIsClosed(segments: TLDrawShapeSegment[], size: TLDefaultSizeStyle): boolean;
    private startShape;
    private updateDrawingShape;
    private getLineLength;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: TLEventHandlers['onInterrupt'];
    complete(): void;
    cancel(): void;
}

declare interface DrawShape extends TDBaseShape {
    type: TDShapeType.Draw;
    points: number[][];
    isComplete: boolean;
}

/** @public */
export declare class DrawShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Drawing | typeof Idle_2)[];
    shapeType: string;
    onExit: () => void;
}

/** @public */
export declare class DrawShapeUtil extends ShapeUtil<TLDrawShape> {
    static type: "draw";
    static props: {
        color: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        dash: EnumStyleProp<"dashed" | "dotted" | "draw" | "solid">;
        fill: EnumStyleProp<"none" | "pattern" | "semi" | "solid">;
        isClosed: Validator<boolean>;
        isComplete: Validator<boolean>;
        isPen: Validator<boolean>;
        segments: ArrayOfValidator<    {
        points: VecModel[];
        type: "free" | "straight";
        }>;
        size: EnumStyleProp<"l" | "m" | "s" | "xl">;
    };
    static migrations: TLShapePropsMigrations;
    hideResizeHandles: (shape: TLDrawShape) => boolean;
    hideRotateHandle: (shape: TLDrawShape) => boolean;
    hideSelectionBoundsFg: (shape: TLDrawShape) => boolean;
    getDefaultProps(): TLDrawShape['props'];
    getGeometry(shape: TLDrawShape): Circle2d | Polyline2d;
    component(shape: TLDrawShape): JSX_2.Element;
    indicator(shape: TLDrawShape): JSX_2.Element;
    toSvg(shape: TLDrawShape, ctx: SvgExportContext): JSX_2.Element;
    getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[];
    onResize: TLOnResizeHandler<TLDrawShape>;
    expandSelectionOutlinePx(shape: TLDrawShape): number;
}

/** @public */
export declare function DrawToolbarItem(): JSX_2.Element;

/** @public */
export declare function DuplicateMenuItem(): JSX_2.Element | null;

declare class EditingShape extends StateNode {
    static id: string;
    hitShapeForPointerUp: null | TLShape;
    onEnter: () => void;
    onExit: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerDown: TLEventHandlers['onPointerDown'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
}

/** @public */
export declare function EditLinkMenuItem(): JSX_2.Element | null;

/** @public */
export declare function EditSubmenu(): JSX_2.Element;

declare interface EllipseShape extends TDBaseShape {
    type: TDShapeType.Ellipse;
    radius: number[];
    label?: string;
    labelPoint?: number[];
}

/** @public */
export declare function EllipseToolbarItem(): JSX_2.Element;

/** @public */
export declare class EmbedShapeUtil extends BaseBoxShapeUtil<TLEmbedShape> {
    static type: "embed";
    static props: {
        h: Validator<number>;
        url: Validator<string>;
        w: Validator<number>;
    };
    static migrations: TLShapePropsMigrations;
    hideSelectionBoundsFg: TLShapeUtilFlag<TLEmbedShape>;
    canEdit: TLShapeUtilFlag<TLEmbedShape>;
    canResize: (shape: TLEmbedShape) => boolean;
    canEditInReadOnly: () => boolean;
    getDefaultProps(): TLEmbedShape['props'];
    isAspectRatioLocked: TLShapeUtilFlag<TLEmbedShape>;
    onResize: TLOnResizeHandler<TLEmbedShape>;
    component(shape: TLEmbedShape): JSX_2.Element;
    indicator(shape: TLEmbedShape): JSX_2.Element;
}

/** @public */
export declare class EraserTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Erasing | typeof Idle_7 | typeof Pointing_6)[];
    onEnter: () => void;
}

/** @public */
export declare function EraserToolbarItem(): JSX_2.Element;

declare class Erasing extends StateNode {
    static id: string;
    private info;
    private scribbleId;
    private markId;
    private excludedShapeIds;
    onEnter: (info: TLPointerEventInfo) => void;
    private pushPointToScribble;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    update(): void;
    complete(): void;
    cancel(): void;
}

/** @public */
export declare type EventsProviderProps = {
    children: React_3.ReactNode;
    onEvent?: TLUiEventHandler;
};

/** @public */
export declare function ExampleDialog({ title, body, cancel, confirm, displayDontShowAgain, onCancel, onContinue, }: {
    body?: string;
    cancel?: string;
    confirm?: string;
    displayDontShowAgain?: boolean;
    onCancel: () => void;
    onContinue: () => void;
    title?: string;
}): JSX_2.Element;

/**
 * Export the given shapes as files.
 *
 * @param editor - The editor instance.
 * @param ids - The ids of the shapes to export.
 * @param format - The format to export as.
 * @param name - Name of the exported file. If undefined a predefined name, based on the selection, will be used.
 * @param opts - Options for the export.
 *
 * @public
 */
export declare function exportAs(editor: Editor, ids: TLShapeId[], format: TLExportType | undefined, name: string | undefined, opts?: Partial<TLSvgOptions>): Promise<void>;

/** @public */
export declare function ExportFileContentSubMenu(): JSX_2.Element;

/**
 * Export the given shapes as a blob.
 * @param editor - The editor instance.
 * @param ids - The ids of the shapes to export.
 * @param format - The format to export as.
 * @param opts - Rendering options.
 * @returns A promise that resolves to a blob.
 * @public
 */
export declare function exportToBlob({ editor, ids, format, opts, }: {
    editor: Editor;
    format: 'jpeg' | 'json' | 'png' | 'svg' | 'webp';
    ids: TLShapeId[];
    opts?: Partial<TLSvgOptions>;
}): Promise<Blob>;

/** @public */
export declare function ExtrasGroup(): JSX_2.Element;

/** @public */
export declare function FeatureFlags(): JSX_2.Element | null;

/**
 * Fit a frame to its content.
 *
 * @param id - Id of the frame you wish to fit to content.
 * @param editor - tlraw editor instance.
 * @param opts - Options for fitting the frame.
 *
 * @public
 */
export declare function fitFrameToContent(editor: Editor, id: TLShapeId, opts?: {
    padding: number;
}): void;

/** @public */
export declare function FitFrameToContentMenuItem(): JSX_2.Element | null;

/** @public */
export declare const FONT_FAMILIES: Record<TLDefaultFontStyle, string>;

declare enum FontStyle {
    Script = "script",
    Sans = "sans",
    Serif = "serif",
    Mono = "mono"
}

/** @public */
export declare class FrameShapeTool extends BaseBoxShapeTool {
    static id: string;
    static initial: string;
    shapeType: string;
    onCreate: (shape: null | TLShape) => void;
}

/** @public */
export declare class FrameShapeUtil extends BaseBoxShapeUtil<TLFrameShape> {
    static type: "frame";
    static props: {
        h: Validator<number>;
        name: Validator<string>;
        w: Validator<number>;
    };
    static migrations: TLShapePropsMigrations;
    canBind: () => boolean;
    canEdit: () => boolean;
    getDefaultProps(): TLFrameShape['props'];
    getGeometry(shape: TLFrameShape): Geometry2d;
    component(shape: TLFrameShape): JSX_2.Element;
    toSvg(shape: TLFrameShape, ctx: SvgExportContext): JSX_2.Element;
    indicator(shape: TLFrameShape): JSX_2.Element;
    canReceiveNewChildrenOfType: (shape: TLShape, _type: TLShape['type']) => boolean;
    providesBackgroundForChildren(): boolean;
    canDropShapes: (shape: TLFrameShape, _shapes: TLShape[]) => boolean;
    onDragShapesOver: (frame: TLFrameShape, shapes: TLShape[]) => void;
    onDragShapesOut: (_shape: TLFrameShape, shapes: TLShape[]) => void;
    onResize: TLOnResizeHandler<any>;
}

/** @public */
export declare function FrameToolbarItem(): JSX_2.Element;

/** @public */
export declare class GeoShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_3 | typeof Pointing_2)[];
    shapeType: string;
}

/** @public */
export declare class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
    static type: "geo";
    static props: {
        align: EnumStyleProp<"end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start">;
        color: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        dash: EnumStyleProp<"dashed" | "dotted" | "draw" | "solid">;
        fill: EnumStyleProp<"none" | "pattern" | "semi" | "solid">;
        font: EnumStyleProp<"draw" | "mono" | "sans" | "serif">;
        geo: EnumStyleProp<"arrow-down" | "arrow-left" | "arrow-right" | "arrow-up" | "check-box" | "cloud" | "diamond" | "ellipse" | "hexagon" | "octagon" | "oval" | "pentagon" | "rectangle" | "rhombus-2" | "rhombus" | "star" | "trapezoid" | "triangle" | "x-box">;
        growY: Validator<number>;
        h: Validator<number>;
        labelColor: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        size: EnumStyleProp<"l" | "m" | "s" | "xl">;
        text: Validator<string>;
        url: Validator<string>;
        verticalAlign: EnumStyleProp<"end" | "middle" | "start">;
        w: Validator<number>;
    };
    static migrations: TLShapePropsMigrations;
    canEdit: () => boolean;
    getDefaultProps(): TLGeoShape['props'];
    getGeometry(shape: TLGeoShape): Group2d;
    getHandleSnapGeometry(shape: TLGeoShape): HandleSnapGeometry;
    onEditEnd: TLOnEditEndHandler<TLGeoShape>;
    component(shape: TLGeoShape): JSX_2.Element;
    indicator(shape: TLGeoShape): JSX_2.Element;
    toSvg(shape: TLGeoShape, ctx: SvgExportContext): JSX_2.Element;
    getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[];
    onResize: TLOnResizeHandler<TLGeoShape>;
    onBeforeCreate: (shape: TLGeoShape) => {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            dash: "dashed" | "dotted" | "draw" | "solid";
            fill: "none" | "pattern" | "semi" | "solid";
            font: "draw" | "mono" | "sans" | "serif";
            geo: "arrow-down" | "arrow-left" | "arrow-right" | "arrow-up" | "check-box" | "cloud" | "diamond" | "ellipse" | "hexagon" | "octagon" | "oval" | "pentagon" | "rectangle" | "rhombus-2" | "rhombus" | "star" | "trapezoid" | "triangle" | "x-box";
            growY: number;
            h: number;
            labelColor: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            size: "l" | "m" | "s" | "xl";
            text: string;
            url: string;
            verticalAlign: "end" | "middle" | "start";
            w: number;
        };
        rotation: number;
        type: "geo";
        typeName: "shape";
        x: number;
        y: number;
    } | undefined;
    onBeforeUpdate: (prev: TLGeoShape, next: TLGeoShape) => {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            dash: "dashed" | "dotted" | "draw" | "solid";
            fill: "none" | "pattern" | "semi" | "solid";
            font: "draw" | "mono" | "sans" | "serif";
            geo: "arrow-down" | "arrow-left" | "arrow-right" | "arrow-up" | "check-box" | "cloud" | "diamond" | "ellipse" | "hexagon" | "octagon" | "oval" | "pentagon" | "rectangle" | "rhombus-2" | "rhombus" | "star" | "trapezoid" | "triangle" | "x-box";
            growY: number;
            h: number;
            labelColor: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            size: "l" | "m" | "s" | "xl";
            text: string;
            url: string;
            verticalAlign: "end" | "middle" | "start";
            w: number;
        };
        rotation: number;
        type: "geo";
        typeName: "shape";
        x: number;
        y: number;
    } | undefined;
    onDoubleClick: (shape: TLGeoShape) => {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            geo: "check-box";
        };
        rotation: number;
        type: "geo";
        typeName: "shape";
        x: number;
        y: number;
    } | {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            geo: "rectangle";
        };
        rotation: number;
        type: "geo";
        typeName: "shape";
        x: number;
        y: number;
    } | undefined;
}

/** @public */
export declare function GeoStylePickerSet({ styles }: {
    styles: ReadonlySharedStyleMap;
}): JSX_2.Element | null;

/**
 * Tests whether an URL supports embedding and returns the result. If we encounter an error, we
 * return undefined.
 *
 * @param inputUrl - The URL to match
 * @public
 */
export declare function getEmbedInfo(inputUrl: string): TLEmbedResult;

/** @public */
export declare function getOccludedChildren(editor: Editor, parent: TLShape): TLShapeId[];

/** @public */
export declare function getPerfectDashProps(totalLength: number, strokeWidth: number, opts?: Partial<{
    closed: boolean;
    end: 'none' | 'outset' | 'skip';
    lengthRatio: number;
    snap: number;
    start: 'none' | 'outset' | 'skip';
    style: TLDefaultDashStyle;
}>): {
    strokeDasharray: string;
    strokeDashoffset: string;
};

/** @public */
export declare function getSvgAsImage(svgString: string, isSafari: boolean, options: {
    height: number;
    quality: number;
    scale: number;
    type: 'jpeg' | 'png' | 'webp';
    width: number;
}): Promise<Blob | null>;

declare function getTranslatingSnapshot(editor: Editor): {
    averagePagePoint: Vec;
    initialPageBounds: Box;
    initialSnapPoints: BoundsSnapPoint[];
    movingShapes: TLShape[];
    noteAdjacentPositions: undefined | Vec[];
    noteSnapshot: MovingShapeSnapshot | undefined;
    shapeSnapshots: MovingShapeSnapshot[];
};

/** @public */
export declare function GroupMenuItem(): JSX_2.Element | null;

/** @public */
export declare function GroupOrUngroupMenuItem(): JSX_2.Element;

declare interface GroupShape extends TDBaseShape {
    type: TDShapeType.Group;
    size: number[];
    children: string[];
}

/** @public */
export declare class HandTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Dragging | typeof Idle_8 | typeof Pointing_7)[];
    onDoubleClick: TLClickEvent;
    onTripleClick: TLClickEvent;
    onQuadrupleClick: TLClickEvent;
}

/** @public */
export declare function HandToolbarItem(): JSX_2.Element;

/** @public */
export declare function HexagonToolbarItem(): JSX_2.Element;

/** @public */
export declare class HighlightShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Drawing | typeof Idle_2)[];
    shapeType: string;
    onExit: () => void;
}

/** @public */
export declare class HighlightShapeUtil extends ShapeUtil<TLHighlightShape> {
    static type: "highlight";
    static props: {
        color: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        isComplete: Validator<boolean>;
        isPen: Validator<boolean>;
        segments: ArrayOfValidator<    {
        points: VecModel[];
        type: "free" | "straight";
        }>;
        size: EnumStyleProp<"l" | "m" | "s" | "xl">;
    };
    static migrations: TLShapePropsMigrations;
    hideResizeHandles: (shape: TLHighlightShape) => boolean;
    hideRotateHandle: (shape: TLHighlightShape) => boolean;
    hideSelectionBoundsFg: (shape: TLHighlightShape) => boolean;
    getDefaultProps(): TLHighlightShape['props'];
    getGeometry(shape: TLHighlightShape): Circle2d | Polygon2d;
    component(shape: TLHighlightShape): JSX_2.Element;
    backgroundComponent(shape: TLHighlightShape): JSX_2.Element;
    indicator(shape: TLHighlightShape): JSX_2.Element;
    toSvg(shape: TLHighlightShape): JSX_2.Element;
    toBackgroundSvg(shape: TLHighlightShape): JSX_2.Element;
    onResize: TLOnResizeHandler<TLHighlightShape>;
}

/** @public */
export declare function HighlightToolbarItem(): JSX_2.Element;

declare class Idle extends StateNode {
    static id: string;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onEnter: () => void;
    onCancel: () => void;
    onKeyUp: TLEventHandlers['onKeyUp'];
}

declare class Idle_10 extends StateNode {
    static id: string;
    onEnter: () => void;
    onExit: TLExitEventHandler;
    onCancel: TLEventHandlers['onCancel'];
    onPointerDown: TLEventHandlers['onPointerDown'];
    onDoubleClick: TLEventHandlers['onDoubleClick'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyRepeat: TLEventHandlers['onKeyRepeat'];
    onKeyUp: TLEventHandlers['onKeyUp'];
    private cancel;
    private cleanupCroppingState;
    private nudgeCroppingImage;
}

declare class Idle_11 extends StateNode {
    static id: string;
    onEnter: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerDown: TLEventHandlers['onPointerDown'];
    onDoubleClick: TLEventHandlers['onDoubleClick'];
    onRightClick: TLEventHandlers['onRightClick'];
    onCancel: TLEventHandlers['onCancel'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyRepeat: TLEventHandlers['onKeyDown'];
    onKeyUp: (info: TLKeyboardEventInfo) => void;
    private shouldStartEditingShape;
    private startEditingShape;
    isDarwin: boolean;
    isOverArrowLabelTest(shape: TLShape | undefined): boolean;
    handleDoubleClickOnCanvas(info: TLClickEventInfo): void;
    private nudgeSelectedShapes;
    private canInteractWithShapeInReadOnly;
}

declare class Idle_12 extends StateNode {
    static id: string;
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    onPointerDown: TLEventHandlers['onPointerUp'];
}

declare class Idle_2 extends StateNode {
    static id: string;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onEnter: () => void;
    onCancel: () => void;
}

declare class Idle_3 extends StateNode {
    static id: string;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onEnter: () => void;
    onKeyUp: TLEventHandlers['onKeyUp'];
    onCancel: () => void;
}

declare class Idle_4 extends StateNode {
    static id: string;
    private shapeId;
    onEnter: (info: {
        shapeId: TLShapeId;
    }) => void;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onCancel: () => void;
}

declare class Idle_5 extends StateNode {
    static id: string;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onEnter: () => void;
    onCancel: () => void;
}

declare class Idle_6 extends StateNode {
    static id: string;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerDown: TLEventHandlers['onPointerDown'];
    onEnter: () => void;
    onKeyDown: TLEventHandlers['onKeyDown'];
    onCancel: () => void;
}

declare class Idle_7 extends StateNode {
    static id: string;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onCancel: () => void;
}

declare class Idle_8 extends StateNode {
    static id: string;
    onEnter: () => void;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onCancel: () => void;
}

declare class Idle_9 extends StateNode {
    static id: string;
    onPointerDown: TLEventHandlers['onPointerDown'];
}

declare interface ImageShape extends TDBaseShape {
    type: TDShapeType.Image;
    size: number[];
    assetId: string;
}

/** @public */
export declare class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
    static type: "image";
    static props: {
        assetId: Validator<TLAssetId | null>;
        crop: Validator<    {
        bottomRight: VecModel;
        topLeft: VecModel;
        } | null>;
        h: Validator<number>;
        playing: Validator<boolean>;
        url: Validator<string>;
        w: Validator<number>;
    };
    static migrations: TLShapePropsMigrations;
    isAspectRatioLocked: () => boolean;
    canCrop: () => boolean;
    getDefaultProps(): TLImageShape['props'];
    component(shape: TLImageShape): JSX_2.Element;
    indicator(shape: TLImageShape): JSX_2.Element | null;
    toSvg(shape: TLImageShape): Promise<JSX_2.Element | null>;
    onDoubleClick: (shape: TLImageShape) => void;
    onDoubleClickEdge: TLOnDoubleClickHandler<TLImageShape>;
}

/** @public */
export declare function isGifAnimated(file: Blob): Promise<boolean>;

declare type Join<T, K> = K extends null ? {
    [R in keyof T]: T[R];
} : {
    [R in keyof T]: T[R];
} & {
    [R in keyof K]: K[R];
};

/** @public */
export declare function KeyboardShortcutsMenuItem(): JSX_2.Element | null;

/* Excluded from this release type: kickoutOccludedShapes */

/** @public */
export declare const LABEL_FONT_SIZES: Record<TLDefaultSizeStyle, number>;

/** @public */
export declare function LanguageMenu(): JSX_2.Element;

declare class Lasering extends StateNode {
    static id: string;
    scribbleId: string;
    onEnter: () => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: () => void;
    private pushPointToScribble;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    private complete;
    private cancel;
}

/** @public */
export declare class LaserTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_9 | typeof Lasering)[];
    onEnter: () => void;
}

/** @public */
export declare function LaserToolbarItem(): JSX_2.Element;

/* Excluded from this release type: LegacyTldrawDocument */

/** @public */
export declare class LineShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_4 | typeof Pointing_3)[];
    shapeType: string;
}

/** @public */
export declare class LineShapeUtil extends ShapeUtil<TLLineShape> {
    static type: "line";
    static props: {
        color: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        dash: EnumStyleProp<"dashed" | "dotted" | "draw" | "solid">;
        points: DictValidator<string, {
        id: string;
        index: IndexKey;
        x: number;
        y: number;
        }>;
        size: EnumStyleProp<"l" | "m" | "s" | "xl">;
        spline: EnumStyleProp<"cubic" | "line">;
    };
    static migrations: TLShapePropsMigrations;
    hideResizeHandles: () => boolean;
    hideRotateHandle: () => boolean;
    hideSelectionBoundsFg: () => boolean;
    hideSelectionBoundsBg: () => boolean;
    getDefaultProps(): TLLineShape['props'];
    getGeometry(shape: TLLineShape): CubicSpline2d | Polyline2d;
    getHandles(shape: TLLineShape): TLHandle[];
    onResize: TLOnResizeHandler<TLLineShape>;
    onHandleDrag: TLOnHandleDragHandler<TLLineShape>;
    component(shape: TLLineShape): JSX_2.Element;
    indicator(shape: TLLineShape): JSX_2.Element;
    toSvg(shape: TLLineShape): JSX_2.Element;
    getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry;
}

/** @public */
export declare function LineToolbarItem(): JSX_2.Element;

/** @public */
export declare function MiscMenuGroup(): JSX_2.Element;

/** @public */
export declare function MoveToPageMenu(): JSX_2.Element | null;

declare interface MovingShapeSnapshot {
    shape: TLShape;
    pagePoint: Vec;
    pageRotation: number;
    parentTransform: MatModel | null;
}

declare function noop(): void;

/** @public */
export declare class NoteShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_5 | typeof Pointing_4)[];
    shapeType: string;
}

/** @public */
export declare class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
    static type: "note";
    static props: {
        align: EnumStyleProp<"end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start">;
        color: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        font: EnumStyleProp<"draw" | "mono" | "sans" | "serif">;
        fontSizeAdjustment: Validator<number>;
        growY: Validator<number>;
        size: EnumStyleProp<"l" | "m" | "s" | "xl">;
        text: Validator<string>;
        url: Validator<string>;
        verticalAlign: EnumStyleProp<"end" | "middle" | "start">;
    };
    static migrations: TLShapePropsMigrations;
    canEdit: () => boolean;
    hideResizeHandles: () => boolean;
    hideSelectionBoundsFg: () => boolean;
    getDefaultProps(): TLNoteShape['props'];
    getGeometry(shape: TLNoteShape): Group2d;
    getHandles(shape: TLNoteShape): TLHandle[];
    component(shape: TLNoteShape): JSX_2.Element;
    indicator(shape: TLNoteShape): JSX_2.Element;
    toSvg(shape: TLNoteShape, ctx: SvgExportContext): JSX_2.Element;
    onBeforeCreate: (next: TLNoteShape) => {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            font: "draw" | "mono" | "sans" | "serif";
            fontSizeAdjustment: number;
            growY: number;
            size: "l" | "m" | "s" | "xl";
            text: string;
            url: string;
            verticalAlign: "end" | "middle" | "start";
        };
        rotation: number;
        type: "note";
        typeName: "shape";
        x: number;
        y: number;
    } | undefined;
    onBeforeUpdate: (prev: TLNoteShape, next: TLNoteShape) => {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            font: "draw" | "mono" | "sans" | "serif";
            fontSizeAdjustment: number;
            growY: number;
            size: "l" | "m" | "s" | "xl";
            text: string;
            url: string;
            verticalAlign: "end" | "middle" | "start";
        };
        rotation: number;
        type: "note";
        typeName: "shape";
        x: number;
        y: number;
    } | undefined;
    onEditEnd: TLOnEditEndHandler<TLNoteShape>;
}

/** @public */
export declare function NoteToolbarItem(): JSX_2.Element;

/** @public */
export declare function OfflineIndicator(): JSX_2.Element;

/** @public */
export declare function OpacitySlider(): JSX_2.Element | null;

/** @public */
export declare function OvalToolbarItem(): JSX_2.Element;

/** @public */
export declare const PageItemInput: ({ name, id, isCurrentPage, }: {
    id: TLPageId;
    isCurrentPage: boolean;
    name: string;
}) => JSX_2.Element;

/** @public */
export declare const PageItemSubmenu: MemoExoticComponent<({ index, listSize, item, onRename, }: PageItemSubmenuProps) => JSX_2.Element>;

/** @public */
declare interface PageItemSubmenuProps {
    index: number;
    item: {
        id: string;
        name: string;
    };
    listSize: number;
    onRename?: () => void;
}

/* Excluded from this release type: parseAndLoadDocument */

/** @public */
export declare function parseTldrawJsonFile({ json, schema, }: {
    json: string;
    schema: TLSchema;
}): Result<TLStore, TldrawFileParseError>;

/** @public */
export declare function PasteMenuItem(): JSX_2.Element;

declare class Pointing extends StateNode {
    static id: string;
    shape?: TLArrowShape;
    markId: string;
    onEnter: () => void;
    onExit: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: TLEventHandlers['onInterrupt'];
    cancel(): void;
    createArrowShape(): void;
    updateArrowShapeEndHandle(): void;
    private preciseTimeout;
    private didTimeout;
    private startPreciseTimeout;
    private clearPreciseTimeout;
}

declare class Pointing_2 extends StateNode {
    static id: string;
    markId: string;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: TLEventHandlers['onInterrupt'];
    private complete;
    private cancel;
}

declare class Pointing_3 extends StateNode {
    static id: string;
    shape: TLLineShape;
    markId: string | undefined;
    onEnter: (info: {
        shapeId?: TLShapeId;
    }) => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: TLInterruptEvent;
    complete(): void;
    cancel(): void;
}

declare class Pointing_4 extends StateNode {
    static id: string;
    dragged: boolean;
    info: TLPointerEventInfo;
    wasFocusedOnEnter: boolean;
    markId: string;
    shape: TLNoteShape;
    onEnter: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onInterrupt: TLInterruptEvent;
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    private complete;
    private cancel;
}

declare class Pointing_5 extends StateNode {
    static id: string;
    shape?: TLTextShape;
    markId: string;
    onExit: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: () => void;
    onComplete: () => void;
    onCancel: () => void;
    onInterrupt: () => void;
    private complete;
    private cancel;
}

declare class Pointing_6 extends StateNode {
    static id: string;
    onEnter: () => void;
    onLongPress: TLEventHandlers['onLongPress'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: TLEventHandlers['onInterrupt'];
    private startErasing;
    complete(): void;
    cancel(): void;
}

declare class Pointing_7 extends StateNode {
    static id: string;
    onEnter: () => void;
    onLongPress: TLEventHandlers['onLongPress'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    private startDragging;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: TLEventHandlers['onInterrupt'];
    private complete;
}

declare class Pointing_8 extends StateNode {
    static id: string;
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    private complete;
    private cancel;
}

declare class PointingArrowLabel extends StateNode {
    static id: string;
    shapeId: TLShapeId;
    markId: string;
    wasAlreadySelected: boolean;
    didDrag: boolean;
    private info;
    private updateCursor;
    onEnter: (info: TLPointerEventInfo & {
        isCreating: boolean;
        onInteractionEnd?: string;
        shape: TLArrowShape;
    }) => void;
    onExit: () => void;
    private _labelDragOffset;
    onPointerMove: () => void;
    onPointerUp: () => void;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private complete;
    private cancel;
}

declare class PointingCanvas extends StateNode {
    static id: string;
    onEnter: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private complete;
}

declare class PointingCrop extends StateNode {
    static id: string;
    onCancel: TLEventHandlers['onCancel'];
    onPointerMove: TLPointerEvent;
    onPointerUp: TLPointerEvent;
}

declare class PointingCropHandle extends StateNode {
    static id: string;
    private info;
    onEnter: (info: TLPointingCropHandleInfo) => void;
    onExit: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onLongPress: TLEventHandlers['onLongPress'];
    private startCropping;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

declare class PointingHandle extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        handle: TLHandle;
        shape: TLShape;
        target: "handle";
    } & {
        target: 'handle';
    };
    onEnter: (info: TLPointerEventInfo & {
        target: 'handle';
    }) => void;
    onExit: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onLongPress: TLEventHandlers['onLongPress'];
    private startDraggingHandle;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

declare class PointingResizeHandle extends StateNode {
    static id: string;
    private info;
    private updateCursor;
    onEnter: (info: PointingResizeHandleInfo) => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onLongPress: TLEventHandlers['onLongPress'];
    private startResizing;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private complete;
    private cancel;
}

declare type PointingResizeHandleInfo = Extract<TLPointerEventInfo, {
    target: 'selection';
}> & {
    onInteractionEnd?: string;
};

declare class PointingRotateHandle extends StateNode {
    static id: string;
    private info;
    private updateCursor;
    onEnter: (info: PointingRotateHandleInfo) => void;
    onExit: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onLongPress: TLEventHandlers['onLongPress'];
    private startRotating;
    onPointerUp: () => void;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private complete;
    private cancel;
}

declare type PointingRotateHandleInfo = Extract<TLPointerEventInfo, {
    target: 'selection';
}> & {
    onInteractionEnd?: string;
};

declare class PointingSelection extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
        target: "selection";
    } & {
        target: 'selection';
    };
    onEnter: (info: TLPointerEventInfo & {
        target: 'selection';
    }) => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onLongPress: TLEventHandlers['onLongPress'];
    private startTranslating;
    onDoubleClick?: TLClickEvent | undefined;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

declare class PointingShape extends StateNode {
    static id: string;
    hitShape: TLShape;
    hitShapeForPointerUp: TLShape;
    isDoubleClick: boolean;
    didSelectOnEnter: boolean;
    onEnter: (info: TLPointerEventInfo & {
        target: 'shape';
    }) => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onDoubleClick: TLEventHandlers['onDoubleClick'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onLongPress: TLEventHandlers['onLongPress'];
    private startTranslating;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

/** @public */
export declare enum PORTRAIT_BREAKPOINT {
    ZERO = 0,
    MOBILE_XXS = 1,
    MOBILE_XS = 2,
    MOBILE_SM = 3,
    MOBILE = 4,
    TABLET_SM = 5,
    TABLET = 6,
    DESKTOP = 7
}

/** @public */
export declare function PreferencesGroup(): JSX_2.Element;

/** @public */
export declare function preloadFont(id: string, font: TLTypeFace): Promise<FontFace>;

/** @public */
export declare function PrintItem(): JSX_2.Element;

declare interface RectangleShape extends TDBaseShape {
    type: TDShapeType.Rectangle;
    size: number[];
    label?: string;
    labelPoint?: number[];
}

/** @public */
export declare function RectangleToolbarItem(): JSX_2.Element;

/**
 * Remove a frame.
 *
 * @param editor - tldraw editor instance.
 * @param ids - Ids of the frames you wish to remove.
 *
 * @public
 */
export declare function removeFrame(editor: Editor, ids: TLShapeId[]): void;

/** @public */
export declare function RemoveFrameMenuItem(): JSX_2.Element | null;

/** @public */
export declare function ReorderMenuItems(): JSX_2.Element;

/** @public */
export declare function ReorderMenuSubmenu(): JSX_2.Element | null;

declare class Resizing extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
        target: "selection";
    } & {
        creationCursorOffset?: undefined | VecLike;
        handle: SelectionCorner | SelectionEdge;
        isCreating?: boolean | undefined;
        onCreate?: ((shape: null | TLShape) => void) | undefined;
        onInteractionEnd?: string | undefined;
        target: "selection";
    };
    markId: string;
    private didHoldCommand;
    creationCursorOffset: VecLike;
    private snapshot;
    onEnter: TLEnterEventHandler;
    onTick: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyUp: TLEventHandlers['onKeyUp'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    private cancel;
    private complete;
    private handleResizeStart;
    private handleResizeEnd;
    private updateShapes;
    private updateCursor;
    onExit: () => void;
    _createSnapshot: () => {
        canShapesDeform: boolean;
        cursorHandleOffset: Vec;
        frames: {
            children: TLShape[];
            id: TLShapeId;
        }[];
        initialSelectionPageBounds: Box;
        selectedShapeIds: TLShapeId[];
        selectionBounds: Box;
        selectionRotation: number;
        shapeSnapshots: Map<TLShapeId, {
            bounds: Box;
            isAspectRatioLocked: boolean;
            pageRotation: number;
            pageTransform: Mat;
            shape: TLShape;
        }>;
    };
    _createShapeSnapshot: (shape: TLShape) => {
        bounds: Box;
        isAspectRatioLocked: boolean;
        pageRotation: number;
        pageTransform: Mat;
        shape: TLShape;
    };
}

/** @public */
export declare function RhombusToolbarItem(): JSX_2.Element;

/** @public */
export declare function RotateCWMenuItem(): JSX_2.Element;

declare class Rotating extends StateNode {
    static id: string;
    snapshot: TLRotationSnapshot;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
        target: "selection";
    } & {
        onInteractionEnd?: string | undefined;
    };
    markId: string;
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd?: string;
        target: 'selection';
    }) => StateNode | undefined;
    onExit: () => void;
    onPointerMove: () => void;
    onKeyDown: () => void;
    onKeyUp: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: () => void;
    private update;
    private cancel;
    private complete;
    _getRotationFromPointerPosition({ snapToNearestDegree }: {
        snapToNearestDegree: boolean;
    }): number;
}

declare class ScribbleBrushing extends StateNode {
    static id: string;
    hits: Set<TLShapeId>;
    size: number;
    scribbleId: string;
    initialSelectedShapeIds: Set<TLShapeId>;
    newlySelectedShapeIds: Set<TLShapeId>;
    onEnter: () => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: () => void;
    onKeyDown: () => void;
    onKeyUp: () => void;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    private pushPointToScribble;
    private updateScribbleSelection;
    private complete;
    private cancel;
}

/** @public */
export declare function SelectAllMenuItem(): JSX_2.Element;

/** @public */
export declare class SelectTool extends StateNode {
    static id: string;
    static initial: string;
    reactor: (() => void) | undefined;
    static children: () => (typeof Brushing | typeof Crop | typeof Cropping | typeof DraggingHandle | typeof EditingShape | typeof Idle_11 | typeof PointingArrowLabel | typeof PointingCanvas | typeof PointingCropHandle | typeof PointingHandle | typeof PointingResizeHandle | typeof PointingRotateHandle | typeof PointingSelection | typeof PointingShape | typeof Resizing | typeof Rotating | typeof ScribbleBrushing | typeof Translating)[];
    private cleanUpDuplicateProps;
    onEnter: () => void;
    onExit: () => void;
}

/** @public */
export declare function SelectToolbarItem(): JSX_2.Element;

/** @public */
export declare function serializeTldrawJson(store: TLStore): Promise<string>;

/** @public */
export declare function serializeTldrawJsonBlob(store: TLStore): Promise<Blob>;

/** @public */
export declare function setDefaultEditorAssetUrls(assetUrls: TLEditorAssetUrls): void;

/* Excluded from this release type: setDefaultUiAssetUrls */

declare type ShapeStyles = {
    color: ColorStyle;
    dash: DashStyle;
    font?: FontStyle;
    isFilled?: boolean;
    scale?: number;
    size: SizeStyle;
    textAlign?: AlignStyle;
};

declare enum SizeStyle {
    Small = "small",
    Medium = "medium",
    Large = "large"
}

/* Excluded from this release type: Spinner */

/** @public */
export declare function SplineStylePickerSet({ styles }: {
    styles: ReadonlySharedStyleMap;
}): JSX_2.Element | null;

/** @public */
export declare function StackMenuItems(): JSX_2.Element;

/** @public */
export declare function StarToolbarItem(): JSX_2.Element;

declare interface StickyShape extends TDBaseShape {
    type: TDShapeType.Sticky;
    size: number[];
    text: string;
}

declare type StyleValuesForUi<T> = readonly {
    readonly icon: string;
    readonly value: T;
}[];

declare type TDAsset = TDImageAsset | TDVideoAsset;

declare type TDAssets = Record<string, TDAsset>;

declare enum TDAssetType {
    Image = "image",
    Video = "video"
}

declare interface TDBaseShape extends TLV1Shape {
    style: ShapeStyles;
    type: TDShapeType;
    label?: string;
    handles?: Record<string, TDHandle>;
}

declare type TDBinding = ArrowBinding;

declare interface TDHandle extends TLV1Handle {
    canBind?: boolean;
    bindingId?: string;
}

declare interface TDImageAsset extends TLV1Asset {
    type: TDAssetType.Image;
    fileName: string;
    src: string;
    size: number[];
}

declare type TDPage = {
    bindings: Record<string, TDBinding>;
    childIndex?: number;
    id: string;
    name?: string;
    shapes: Record<string, TDShape>;
};

declare type TDShape = ArrowShape | DrawShape | EllipseShape | GroupShape | ImageShape | RectangleShape | StickyShape | TextShape | TriangleShape | VideoShape;

declare enum TDShapeType {
    Sticky = "sticky",
    Ellipse = "ellipse",
    Rectangle = "rectangle",
    Triangle = "triangle",
    Draw = "draw",
    Arrow = "arrow",
    Text = "text",
    Group = "group",
    Image = "image",
    Video = "video"
}

declare interface TDVideoAsset extends TLV1Asset {
    type: TDAssetType.Video;
    fileName: string;
    src: string;
    size: number[];
}

/** @public */
export declare const TEXT_PROPS: {
    fontStyle: string;
    fontVariant: string;
    fontWeight: string;
    lineHeight: number;
    padding: string;
};

/** @public */
export declare const TextLabel: React_2.NamedExoticComponent<TextLabelProps>;

declare type TextLabelProps = {
    align: TLDefaultHorizontalAlignStyle;
    bounds?: Box;
    classNamePrefix?: string;
    fill?: TLDefaultFillStyle;
    font: TLDefaultFontStyle;
    fontSize: number;
    id: TLShapeId;
    isNote?: boolean;
    isSelected: boolean;
    labelColor: string;
    lineHeight: number;
    onKeyDown?: (e: React_2.KeyboardEvent<HTMLTextAreaElement>) => void;
    style?: React_2.CSSProperties;
    text: string;
    textHeight?: number;
    textWidth?: number;
    type: string;
    verticalAlign: TLDefaultVerticalAlignStyle;
    wrap?: boolean;
};

declare interface TextShape extends TDBaseShape {
    type: TDShapeType.Text;
    text: string;
}

/** @public */
export declare class TextShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_6 | typeof Pointing_5)[];
    shapeType: string;
}

/** @public */
export declare class TextShapeUtil extends ShapeUtil<TLTextShape> {
    static type: "text";
    static props: {
        align: EnumStyleProp<"end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start">;
        autoSize: Validator<boolean>;
        color: EnumStyleProp<"black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow">;
        font: EnumStyleProp<"draw" | "mono" | "sans" | "serif">;
        scale: Validator<number>;
        size: EnumStyleProp<"l" | "m" | "s" | "xl">;
        text: Validator<string>;
        w: Validator<number>;
    };
    static migrations: TLShapePropsMigrations;
    getDefaultProps(): TLTextShape['props'];
    getMinDimensions(shape: TLTextShape): {
        height: number;
        width: number;
    };
    getGeometry(shape: TLTextShape): Rectangle2d;
    canEdit: () => boolean;
    isAspectRatioLocked: TLShapeUtilFlag<TLTextShape>;
    component(shape: TLTextShape): JSX_2.Element;
    indicator(shape: TLTextShape): JSX_2.Element | null;
    toSvg(shape: TLTextShape, ctx: SvgExportContext): JSX_2.Element;
    onResize: TLOnResizeHandler<TLTextShape>;
    onBeforeCreate: (shape: TLTextShape) => {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            autoSize: boolean;
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            font: "draw" | "mono" | "sans" | "serif";
            scale: number;
            size: "l" | "m" | "s" | "xl";
            text: string;
            w: number;
        };
        rotation: number;
        type: "text";
        typeName: "shape";
        x: number;
        y: number;
    } | undefined;
    onEditEnd: TLOnEditEndHandler<TLTextShape>;
    onBeforeUpdate: (prev: TLTextShape, next: TLTextShape) => {
        id: TLShapeId;
        index: IndexKey;
        isLocked: boolean;
        meta: JsonObject;
        opacity: number;
        parentId: TLParentId;
        props: {
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            autoSize: boolean;
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "white" | "yellow";
            font: "draw" | "mono" | "sans" | "serif";
            scale: number;
            size: "l" | "m" | "s" | "xl";
            text: string;
            w: number;
        };
        rotation: number;
        type: "text";
        typeName: "shape";
        x: number;
        y: number;
    } | undefined;
    onDoubleClickEdge: (shape: TLTextShape) => {
        id: TLShapeId;
        props: {
            autoSize: boolean;
            scale?: undefined;
        };
        type: "text";
    } | {
        id: TLShapeId;
        props: {
            autoSize?: undefined;
            scale: number;
        };
        type: "text";
    } | undefined;
}

/** @public */
export declare function TextStylePickerSet({ theme, styles, }: {
    styles: ReadonlySharedStyleMap;
    theme: TLDefaultColorTheme;
}): JSX_2.Element | null;

/** @public */
export declare function TextToolbarItem(): JSX_2.Element;

/**@public */
export declare type TLComponents = Expand<TLEditorComponents & TLUiComponents>;

/** @public */
declare type TLCopyType = 'jpeg' | 'json' | 'png' | 'svg';

/** @public */
export declare function Tldraw(props: TldrawProps): JSX_2.Element;

/** @public */
export declare const TLDRAW_FILE_EXTENSION: ".tldr";

/** @public */
export declare interface TldrawFile {
    tldrawFileFormatVersion: number;
    schema: SerializedSchema;
    records: UnknownRecord[];
}

/** @public */
declare type TldrawFileParseError = {
    cause: unknown;
    type: 'invalidRecords';
} | {
    cause: unknown;
    type: 'notATldrawFile';
} | {
    data: any;
    type: 'v1File';
} | {
    reason: MigrationFailureReason;
    type: 'migrationFailed';
} | {
    type: 'fileFormatVersionTooNew';
    version: number;
};

/** @public */
export declare function TldrawHandles({ children }: TLHandlesProps): JSX_2.Element | null;

/**
 * A renderered SVG image of a Tldraw snapshot.
 *
 * @example
 * ```tsx
 * <TldrawImage
 * 	snapshot={snapshot}
 * 	pageId={pageId}
 * 	background={false}
 *  darkMode={true}
 *  bounds={new Box(0,0,600,400)}
 *  scale={1}
 * />
 * ```
 *
 * @public
 */
export declare const TldrawImage: NamedExoticComponent<    {
background?: boolean | undefined;
bounds?: Box | undefined;
darkMode?: boolean | undefined;
format?: "png" | "svg" | undefined;
padding?: number | undefined;
pageId?: TLPageId | undefined;
preserveAspectRatio?: string | undefined;
scale?: number | undefined;
shapeUtils?: readonly TLAnyShapeUtilConstructor[] | undefined;
snapshot: StoreSnapshot<TLRecord>;
}>;

/**
 * Props for the {@link tldraw#TldrawImage} component.
 *
 * @public
 **/
export declare type TldrawImageProps = Expand<{
    /**
     * Additional shape utils to use.
     */
    shapeUtils?: readonly TLAnyShapeUtilConstructor[];
    /**
     * The image format to use. Defaults to 'svg'.
     */
    format?: 'png' | 'svg';
    /**
     * The page to display. Defaults to the first page.
     */
    pageId?: TLPageId;
    /**
     * The snapshot to display.
     */
    snapshot: StoreSnapshot<TLRecord>;
} & Partial<TLSvgOptions>>;

/** @public */
export declare type TldrawProps = Expand<(Omit<TldrawUiProps, 'components'> & Omit<TldrawEditorBaseProps, 'components'> & {
    components?: TLComponents;
}) & Partial<TLExternalContentProps> & ({
    /**
     * A snapshot to load for the store's initial data / schema.
     */
    snapshot?: StoreSnapshot<TLRecord>;
    defaultName?: string;
    migrations?: readonly MigrationSequence[];
    persistenceKey?: string;
    sessionId?: string;
    store?: undefined;
} | {
    store: TLStore | TLStoreWithStatus;
})>;

/** @public */
export declare function TldrawScribble({ scribble, zoom, color, opacity, className }: TLScribbleProps): JSX_2.Element | null;

/** @public */
export declare const TldrawSelectionBackground: ({ bounds, rotation }: TLSelectionBackgroundProps) => JSX_2.Element | null;

/** @public */
export declare const TldrawSelectionForeground: MemoExoticComponent<({ bounds, rotation, }: TLSelectionForegroundProps) => JSX_2.Element | null>;

/**
 * @public
 */
export declare const TldrawUi: React_2.NamedExoticComponent<{
    assetUrls?: (RecursivePartial<TLUiAssetUrls> & RecursivePartial<TLUiAssetUrls>) | undefined;
    children?: ReactNode;
    components?: Partial<{
        ActionsMenu: null | React_2.ComponentType<TLUiActionsMenuProps>;
        ContextMenu: null | React_2.ComponentType<TLUiContextMenuProps>;
        DebugMenu: null | React_2.ComponentType;
        DebugPanel: null | React_2.ComponentType;
        HelperButtons: null | React_2.ComponentType<TLUiHelperButtonsProps>;
        HelpMenu: null | React_2.ComponentType<TLUiHelpMenuProps>;
        KeyboardShortcutsDialog: null | React_2.ComponentType<TLUiKeyboardShortcutsDialogProps>;
        MainMenu: null | React_2.ComponentType<TLUiMainMenuProps>;
        MenuPanel: null | React_2.ComponentType;
        Minimap: null | React_2.ComponentType;
        NavigationPanel: null | React_2.ComponentType;
        PageMenu: null | React_2.ComponentType;
        QuickActions: null | React_2.ComponentType<TLUiQuickActionsProps>;
        SharePanel: null | React_2.ComponentType;
        StylePanel: null | React_2.ComponentType<TLUiStylePanelProps>;
        Toolbar: null | React_2.ComponentType;
        TopPanel: null | React_2.ComponentType;
        ZoomMenu: null | React_2.ComponentType<TLUiZoomMenuProps>;
    }> | undefined;
    forceMobile?: boolean | undefined;
    hideUi?: boolean | undefined;
    onUiEvent?: TLUiEventHandler | undefined;
    overrides?: Partial<{
        actions: TLUiOverride<TLUiActionsContextType, {
        addDialog: (dialog: Omit<TLUiDialog, "id"> & {
        id?: string | undefined;
        }) => string;
        addToast: (toast: Omit<TLUiToast, "id"> & {
        id?: string | undefined;
        }) => string;
        clearDialogs: () => void;
        clearToasts: () => void;
        isMobile: boolean;
        msg: (id?: string | undefined) => string;
        removeDialog: (id: string) => string;
        removeToast: (id: string) => string;
        updateDialog: (id: string, newDialogData: Partial<TLUiDialog>) => string;
        }>;
        tools: TLUiOverride<TLUiToolsContextType, {
        insertMedia: () => void;
        } & {
        addDialog: (dialog: Omit<TLUiDialog, "id"> & {
        id?: string | undefined;
        }) => string;
        addToast: (toast: Omit<TLUiToast, "id"> & {
        id?: string | undefined;
        }) => string;
        clearDialogs: () => void;
        clearToasts: () => void;
        isMobile: boolean;
        msg: (id?: string | undefined) => string;
        removeDialog: (id: string) => string;
        removeToast: (id: string) => string;
        updateDialog: (id: string, newDialogData: Partial<TLUiDialog>) => string;
        }>;
        translations: Record<string, Record<string, string>> | undefined;
    }> | Partial<{
        actions: TLUiOverride<TLUiActionsContextType, {
        addDialog: (dialog: Omit<TLUiDialog, "id"> & {
        id?: string | undefined;
        }) => string;
        addToast: (toast: Omit<TLUiToast, "id"> & {
        id?: string | undefined;
        }) => string;
        clearDialogs: () => void;
        clearToasts: () => void;
        isMobile: boolean;
        msg: (id?: string | undefined) => string;
        removeDialog: (id: string) => string;
        removeToast: (id: string) => string;
        updateDialog: (id: string, newDialogData: Partial<TLUiDialog>) => string;
        }>;
        tools: TLUiOverride<TLUiToolsContextType, {
        insertMedia: () => void;
        } & {
        addDialog: (dialog: Omit<TLUiDialog, "id"> & {
        id?: string | undefined;
        }) => string;
        addToast: (toast: Omit<TLUiToast, "id"> & {
        id?: string | undefined;
        }) => string;
        clearDialogs: () => void;
        clearToasts: () => void;
        isMobile: boolean;
        msg: (id?: string | undefined) => string;
        removeDialog: (id: string) => string;
        removeToast: (id: string) => string;
        updateDialog: (id: string, newDialogData: Partial<TLUiDialog>) => string;
        }>;
        translations: Record<string, Record<string, string>> | undefined;
    }>[] | undefined;
    renderDebugMenuItems?: (() => React_2.ReactNode) | undefined;
}>;

/**
 * Base props for the {@link tldraw#Tldraw} and {@link TldrawUi} components.
 *
 * @public
 */
export declare interface TldrawUiBaseProps {
    /**
     * The component's children.
     */
    children?: ReactNode;
    /**
     * Whether to hide the user interface and only display the canvas.
     */
    hideUi?: boolean;
    /**
     * Overrides for the UI components.
     */
    components?: TLUiComponents;
    /**
     * Additional items to add to the debug menu (will be deprecated)
     */
    renderDebugMenuItems?: () => React_2.ReactNode;
    /** Asset URL override. */
    assetUrls?: TLUiAssetUrlOverrides;
}

/** @public */
export declare const TldrawUiButton: React_3.ForwardRefExoticComponent<TLUiButtonProps & React_3.RefAttributes<HTMLButtonElement>>;

/** @public */
export declare function TldrawUiButtonCheck({ checked }: TLUiButtonCheckProps): JSX_2.Element;

/** @public */
export declare function TldrawUiButtonIcon({ icon, small, invertIcon }: TLUiButtonIconProps): JSX_2.Element;

/** @public */
export declare function TldrawUiButtonLabel({ children }: TLUiButtonLabelProps): JSX_2.Element;

/** @public */
export declare const TldrawUiButtonPicker: typeof _TldrawUiButtonPicker;

declare function _TldrawUiButtonPicker<T extends string>(props: TLUiButtonPickerProps<T>): JSX_2.Element;

/** @public */
export declare function TldrawUiComponentsProvider({ overrides, children, }: TLUiComponentsProviderProps): JSX_2.Element;

/** @public */
export declare function TldrawUiContextProvider({ overrides, components, assetUrls, onUiEvent, forceMobile, children, }: TldrawUiContextProviderProps): JSX_2.Element;

/**
 * Props for the {@link tldraw#Tldraw} and {@link TldrawUi} components.
 *
 * @public
 **/
export declare interface TldrawUiContextProviderProps {
    /**
     * Urls for where to find fonts and other assets for the UI.
     */
    assetUrls?: RecursivePartial<TLUiAssetUrls>;
    /**
     * Overrides for the UI.
     */
    overrides?: TLUiOverrides | TLUiOverrides[];
    /**
     * Overrides for the UI components.
     */
    components?: TLUiComponents;
    /**
     * Callback for when an event occurs in the UI.
     */
    onUiEvent?: TLUiEventHandler;
    /**
     * Whether to always should the mobile breakpoints.
     */
    forceMobile?: boolean;
    /**
     * The component's children.
     */
    children?: ReactNode;
}

/** @public */
export declare function TldrawUiDialogBody({ className, children, style }: TLUiDialogBodyProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDialogCloseButton(): JSX_2.Element;

/** @public */
export declare function TldrawUiDialogFooter({ className, children }: TLUiDialogFooterProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDialogHeader({ className, children }: TLUiDialogHeaderProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDialogTitle({ className, children }: TLUiDialogTitleProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuCheckboxItem({ children, onSelect, ...rest }: TLUiDropdownMenuCheckboxItemProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuContent({ side, align, sideOffset, alignOffset, children, }: TLUiDropdownMenuContentProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuGroup({ children }: TLUiDropdownMenuGroupProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuIndicator(): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuItem({ noClose, children }: TLUiDropdownMenuItemProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuRoot({ id, children, modal, debugOpen, }: TLUiDropdownMenuRootProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuSub({ id, children }: TLUiDropdownMenuSubProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuSubTrigger({ id, label, title, disabled, }: TLUiDropdownMenuSubTriggerProps): JSX_2.Element;

/** @public */
export declare function TldrawUiDropdownMenuTrigger({ children, ...rest }: TLUiDropdownMenuTriggerProps): JSX_2.Element;

/** @public */
export declare const TldrawUiIcon: NamedExoticComponent<TLUiIconProps>;

/** @public */
export declare const TldrawUiInput: React_3.ForwardRefExoticComponent<TLUiInputProps & React_3.RefAttributes<HTMLInputElement>>;

/** @public */
export declare function TldrawUiKbd({ children, visibleOnMobileLayout }: TLUiKbdProps): JSX_2.Element | null;

/** @public */
export declare function TldrawUiMenuCheckboxItem<TranslationKey extends string = string, IconType extends string = string>({ id, kbd, label, readonlyOk, onSelect, disabled, checked, }: TLUiMenuCheckboxItemProps<TranslationKey, IconType>): JSX_2.Element | null;

/** @public */
export declare function TldrawUiMenuContextProvider({ type, sourceId, children, }: TLUiMenuContextProviderProps): JSX_2.Element;

/** @public */
declare type TldrawUiMenuContextType = 'context-menu' | 'helper-buttons' | 'icons' | 'keyboard-shortcuts' | 'menu' | 'panel' | 'small-icons' | 'toolbar-overflow' | 'toolbar';

/** @public */
export declare function TldrawUiMenuGroup({ id, label, children }: TLUiMenuGroupProps): boolean | JSX_2.Element | Iterable<ReactNode> | null | number | string | undefined;

/** @public */
export declare function TldrawUiMenuItem<TranslationKey extends string = string, IconType extends string = string>({ disabled, spinner, readonlyOk, id, kbd, label, icon, onSelect, noClose, isSelected, }: TLUiMenuItemProps<TranslationKey, IconType>): JSX_2.Element | null;

/** @public */
export declare function TldrawUiMenuSubmenu<Translation extends string = string>({ id, disabled, label, size, children, }: TLUiMenuSubmenuProps<Translation>): boolean | JSX_2.Element | Iterable<ReactNode> | null | number | string | undefined;

/** @public */
export declare function TldrawUiPopover({ id, children, onOpenChange, open }: TLUiPopoverProps): JSX_2.Element;

/** @public */
export declare function TldrawUiPopoverContent({ side, children, align, sideOffset, alignOffset, }: TLUiPopoverContentProps): JSX_2.Element;

/** @public */
export declare function TldrawUiPopoverTrigger({ children }: TLUiPopoverTriggerProps): JSX_2.Element;

/**
 * Props for the {@link tldraw#Tldraw} and {@link TldrawUi} components.
 *
 * @public
 */
export declare type TldrawUiProps = Expand<TldrawUiBaseProps & TldrawUiContextProviderProps>;

/* Excluded from this release type: TldrawUiSlider */

/** @public */
declare type TLEditorAssetUrls = {
    fonts: {
        draw: string;
        monospace: string;
        sansSerif: string;
        serif: string;
    };
};

/** @public */
declare type TLEmbedResult = {
    definition: EmbedDefinition;
    embedUrl: string;
    url: string;
} | undefined;

/** @public */
export declare type TLExportType = 'jpeg' | 'json' | 'png' | 'svg' | 'webp';

/** @public */
declare type TLExternalContentProps = {
    acceptedImageMimeTypes: readonly string[];
    acceptedVideoMimeTypes: readonly string[];
    maxAssetSize: number;
    maxImageDimension: number;
};

declare type TLPointingCropHandleInfo = TLPointerEventInfo & {
    target: 'selection';
} & {
    onInteractionEnd?: string;
};

/** @public */
declare type TLTypeFace = {
    display?: any;
    featureSettings?: string;
    format?: string;
    stretch?: string;
    style?: string;
    unicodeRange?: string;
    url: string;
    variant?: string;
    weight?: string;
};

/** @public */
export declare interface TLUiActionItem<TransationKey extends string = string, IconType extends string = string> {
    icon?: IconType;
    id: string;
    kbd?: string;
    label?: {
        [key: string]: TransationKey;
    } | TransationKey;
    readonlyOk?: boolean;
    checkbox?: boolean;
    onSelect: (source: TLUiEventSource) => Promise<void> | void;
}

/** @public */
export declare type TLUiActionsContextType = Record<string, TLUiActionItem>;

/** @public */
export declare type TLUiActionsMenuProps = {
    children?: ReactNode;
};

/** @public */
export declare type TLUiAssetUrlOverrides = RecursivePartial<TLUiAssetUrls>;

declare type TLUiAssetUrls = TLEditorAssetUrls & {
    embedIcons: Record<(typeof EMBED_DEFINITIONS)[number]['type'], string>;
    icons: Record<Exclude<string, TLUiIconType> | TLUiIconType, string>;
    translations: Record<(typeof LANGUAGES)[number]['locale'], string>;
};

/** @public */
export declare type TLUiButtonCheckProps = {
    checked: boolean;
};

/** @public */
export declare type TLUiButtonIconProps = {
    icon: string;
    invertIcon?: boolean;
    small?: boolean;
};

/** @public */
export declare type TLUiButtonLabelProps = {
    children?: ReactNode;
};

/** @public */
export declare interface TLUiButtonPickerProps<T extends string> {
    title: string;
    uiType: string;
    style: StyleProp<T>;
    value: SharedStyle<T>;
    items: StyleValuesForUi<T>;
    theme: TLDefaultColorTheme;
    onValueChange: (style: StyleProp<T>, value: T, squashing: boolean) => void;
}

/** @public */
export declare interface TLUiButtonProps extends React_3.HTMLAttributes<HTMLButtonElement> {
    disabled?: boolean;
    type: 'danger' | 'help' | 'icon' | 'low' | 'menu' | 'normal' | 'primary' | 'tool';
}

/** @public */
export declare type TLUiComponents = Partial<{
    [K in keyof BaseTLUiComponents]: BaseTLUiComponents[K] | null;
}>;

/** @public */
export declare type TLUiComponentsProviderProps = {
    children: ReactNode;
    overrides?: TLUiComponents;
};

/** @public */
export declare interface TLUiContextMenuProps {
    children?: ReactNode;
}

/** @public */
export declare type TLUiDebugMenuProps = {
    children?: ReactNode;
};

/** @public */
export declare interface TLUiDialog {
    id: string;
    onClose?: () => void;
    component: ComponentType<TLUiDialogProps>;
}

/** @public */
export declare type TLUiDialogBodyProps = {
    children: ReactNode;
    className?: string;
    style?: React.CSSProperties;
};

/** @public */
export declare type TLUiDialogFooterProps = {
    children: ReactNode;
    className?: string;
};

/** @public */
export declare type TLUiDialogHeaderProps = {
    children: ReactNode;
    className?: string;
};

/** @public */
export declare interface TLUiDialogProps {
    onClose: () => void;
}

/** @public */
export declare type TLUiDialogsContextType = {
    addDialog: (dialog: Omit<TLUiDialog, 'id'> & {
        id?: string;
    }) => string;
    clearDialogs: () => void;
    dialogs: TLUiDialog[];
    removeDialog: (id: string) => string;
    updateDialog: (id: string, newDialogData: Partial<TLUiDialog>) => string;
};

/** @public */
export declare type TLUiDialogTitleProps = {
    children: ReactNode;
    className?: string;
};

/** @public */
export declare interface TLUiDropdownMenuCheckboxItemProps {
    checked?: boolean;
    onSelect?: (e: Event) => void;
    disabled?: boolean;
    title: string;
    children: ReactNode;
}

/** @public */
export declare type TLUiDropdownMenuContentProps = {
    align?: 'center' | 'end' | 'start';
    alignOffset?: number;
    children: ReactNode;
    id?: string;
    side?: 'bottom' | 'left' | 'right' | 'top';
    sideOffset?: number;
};

/** @public */
export declare type TLUiDropdownMenuGroupProps = {
    children: ReactNode;
};

/** @public */
export declare interface TLUiDropdownMenuItemProps {
    noClose?: boolean;
    children: ReactNode;
}

/** @public */
export declare type TLUiDropdownMenuRootProps = {
    children: ReactNode;
    debugOpen?: boolean;
    id: string;
    modal?: boolean;
};

/** @public */
export declare type TLUiDropdownMenuSubProps = {
    children: ReactNode;
    id: string;
};

/** @public */
export declare type TLUiDropdownMenuSubTriggerProps = {
    disabled?: boolean;
    id?: string;
    label: string;
    title?: string;
};

/** @public */
export declare interface TLUiDropdownMenuTriggerProps {
    children?: ReactNode;
}

/** @public */
export declare type TLUiEventContextType = TLUiEventHandler<keyof TLUiEventMap>;

/** @public */
export declare type TLUiEventHandler<T extends keyof TLUiEventMap = keyof TLUiEventMap> = (name: T, data: Join<{
    source: TLUiEventSource;
}, TLUiEventMap[T]>) => void;

/** @public */
export declare interface TLUiEventMap {
    undo: null;
    redo: null;
    'change-language': {
        locale: string;
    };
    'new-page': null;
    'move-to-page': null;
    'group-shapes': null;
    'ungroup-shapes': null;
    'remove-frame': null;
    'fit-frame-to-content': null;
    'convert-to-embed': null;
    'convert-to-bookmark': null;
    'open-embed-link': null;
    'toggle-auto-size': null;
    'copy-as': {
        format: 'json' | 'png' | 'svg';
    };
    'export-as': {
        format: 'json' | 'png' | 'svg';
    };
    'export-all-as': {
        format: 'json' | 'png' | 'svg';
    };
    'edit-link': null;
    'insert-embed': null;
    'insert-media': null;
    'align-shapes': {
        operation: 'bottom' | 'center-horizontal' | 'center-vertical' | 'left' | 'right' | 'top';
    };
    'duplicate-shapes': null;
    'pack-shapes': null;
    'stack-shapes': {
        operation: 'horizontal' | 'vertical';
    };
    'flip-shapes': {
        operation: 'horizontal' | 'vertical';
    };
    'distribute-shapes': {
        operation: 'horizontal' | 'vertical';
    };
    'stretch-shapes': {
        operation: 'horizontal' | 'vertical';
    };
    'reorder-shapes': {
        operation: 'backward' | 'forward' | 'toBack' | 'toFront';
    };
    'delete-shapes': null;
    'select-all-shapes': null;
    'select-none-shapes': null;
    'rotate-ccw': null;
    'rotate-cw': null;
    'zoom-in': null;
    'zoom-out': null;
    'zoom-to-fit': null;
    'zoom-to-selection': null;
    'reset-zoom': null;
    'zoom-into-view': null;
    'zoom-to-content': null;
    'open-menu': {
        id: string;
    };
    'close-menu': {
        id: string;
    };
    'create-new-project': null;
    'save-project-to-file': null;
    'open-file': null;
    'select-tool': {
        id: string;
    };
    print: null;
    copy: null;
    paste: null;
    cut: null;
    'set-style': {
        id: string;
        value: number | string;
    };
    'toggle-transparent': null;
    'toggle-snap-mode': null;
    'toggle-tool-lock': null;
    'toggle-grid-mode': null;
    'toggle-dark-mode': null;
    'toggle-wrap-mode': null;
    'toggle-focus-mode': null;
    'toggle-debug-mode': null;
    'toggle-lock': null;
    'toggle-reduce-motion': null;
    'toggle-edge-scrolling': null;
    'exit-pen-mode': null;
    'stop-following': null;
    'open-cursor-chat': null;
    'zoom-tool': null;
    'unlock-all': null;
}

/** @public */
export declare type TLUiEventSource = 'actions-menu' | 'context-menu' | 'debug-panel' | 'dialog' | 'document-name' | 'export-menu' | 'help-menu' | 'helper-buttons' | 'kbd' | 'main-menu' | 'menu' | 'navigation-zone' | 'page-menu' | 'people-menu' | 'quick-actions' | 'share-menu' | 'style-panel' | 'toolbar' | 'unknown' | 'zoom-menu';

/** @public */
export declare type TLUiHelperButtonsProps = {
    children?: ReactNode;
};

/** @public */
export declare type TLUiHelpMenuProps = {
    children?: ReactNode;
};

/** @public */
export declare interface TLUiIconProps extends React.HTMLProps<HTMLDivElement> {
    icon: Exclude<string, TLUiIconType> | TLUiIconType;
    small?: boolean;
    color?: string;
    children?: undefined;
    invertIcon?: boolean;
    crossOrigin?: 'anonymous' | 'use-credentials';
}

/** @public */
export declare type TLUiIconType = 'align-bottom-center' | 'align-bottom-left' | 'align-bottom-right' | 'align-bottom' | 'align-center-center' | 'align-center-horizontal' | 'align-center-left' | 'align-center-right' | 'align-center-vertical' | 'align-left' | 'align-right' | 'align-top-center' | 'align-top-left' | 'align-top-right' | 'align-top' | 'arrow-left' | 'arrowhead-arrow' | 'arrowhead-bar' | 'arrowhead-diamond' | 'arrowhead-dot' | 'arrowhead-none' | 'arrowhead-square' | 'arrowhead-triangle-inverted' | 'arrowhead-triangle' | 'aspect-ratio' | 'avatar' | 'blob' | 'bring-forward' | 'bring-to-front' | 'check-circle' | 'check' | 'checkbox-checked' | 'checkbox-empty' | 'chevron-down' | 'chevron-left' | 'chevron-right' | 'chevron-up' | 'chevrons-ne' | 'chevrons-sw' | 'clipboard-copied' | 'clipboard-copy' | 'code' | 'collab' | 'color' | 'comment' | 'cross-2' | 'cross-circle' | 'cross' | 'dash-dashed' | 'dash-dotted' | 'dash-draw' | 'dash-solid' | 'discord' | 'distribute-horizontal' | 'distribute-vertical' | 'dot' | 'dots-horizontal' | 'dots-vertical' | 'drag-handle-dots' | 'duplicate' | 'edit' | 'error' | 'external-link' | 'file' | 'fill-none' | 'fill-pattern' | 'fill-semi' | 'fill-solid' | 'follow' | 'following' | 'font-draw' | 'font-mono' | 'font-sans' | 'font-serif' | 'geo-arrow-down' | 'geo-arrow-left' | 'geo-arrow-right' | 'geo-arrow-up' | 'geo-check-box' | 'geo-cloud' | 'geo-diamond' | 'geo-ellipse' | 'geo-hexagon' | 'geo-octagon' | 'geo-oval' | 'geo-pentagon' | 'geo-rectangle' | 'geo-rhombus-2' | 'geo-rhombus' | 'geo-star' | 'geo-trapezoid' | 'geo-triangle' | 'geo-x-box' | 'github' | 'group' | 'hidden' | 'image' | 'info-circle' | 'leading' | 'link' | 'lock-small' | 'lock' | 'menu' | 'minus' | 'mixed' | 'pack' | 'page' | 'plus' | 'question-mark-circle' | 'question-mark' | 'redo' | 'reset-zoom' | 'rotate-ccw' | 'rotate-cw' | 'ruler' | 'search' | 'send-backward' | 'send-to-back' | 'settings-horizontal' | 'settings-vertical-1' | 'settings-vertical' | 'share-1' | 'share-2' | 'size-extra-large' | 'size-large' | 'size-medium' | 'size-small' | 'spline-cubic' | 'spline-line' | 'stack-horizontal' | 'stack-vertical' | 'status-offline' | 'status-online' | 'stretch-horizontal' | 'stretch-vertical' | 'text-align-center' | 'text-align-justify' | 'text-align-left' | 'text-align-right' | 'tool-arrow' | 'tool-embed' | 'tool-eraser' | 'tool-frame' | 'tool-hand' | 'tool-highlight' | 'tool-laser' | 'tool-line' | 'tool-media' | 'tool-note' | 'tool-pencil' | 'tool-pointer' | 'tool-text' | 'trash' | 'triangle-down' | 'triangle-up' | 'twitter' | 'undo' | 'ungroup' | 'unlock-small' | 'unlock' | 'vertical-align-center' | 'vertical-align-end' | 'vertical-align-start' | 'visible' | 'warning-triangle' | 'zoom-in' | 'zoom-out';

/** @public */
export declare interface TLUiInputProps {
    disabled?: boolean;
    label?: Exclude<string, TLUiTranslationKey> | TLUiTranslationKey;
    icon?: Exclude<string, TLUiIconType> | TLUiIconType;
    iconLeft?: Exclude<string, TLUiIconType> | TLUiIconType;
    autofocus?: boolean;
    autoselect?: boolean;
    children?: React_3.ReactNode;
    defaultValue?: string;
    placeholder?: string;
    onComplete?: (value: string) => void;
    onValueChange?: (value: string) => void;
    onCancel?: (value: string) => void;
    onBlur?: (value: string) => void;
    className?: string;
    /**
     * Usually on iOS when you focus an input, the browser will adjust the viewport to bring the input
     * into view. Sometimes this doesn't work properly though - for example, if the input is newly
     * created, iOS seems to have a hard time adjusting the viewport for it. This prop allows you to
     * opt-in to some extra code to manually bring the input into view when the visual viewport of the
     * browser changes, but we don't want to use it everywhere because generally the native behavior
     * looks nicer in scenarios where it's sufficient.
     */
    shouldManuallyMaintainScrollPositionWhenFocused?: boolean;
    value?: string;
}

/** @public */
export declare interface TLUiKbdProps {
    children: string;
    visibleOnMobileLayout?: boolean;
}

/** @public */
export declare type TLUiKeyboardShortcutsDialogProps = TLUiDialogProps & {
    children?: ReactNode;
};

/** @public */
export declare type TLUiMainMenuProps = {
    children?: ReactNode;
};

/** @public */
export declare type TLUiMenuCheckboxItemProps<TranslationKey extends string = string, IconType extends string = string> = {
    checked?: boolean;
    disabled?: boolean;
    icon?: IconType;
    id: string;
    kbd?: string;
    label?: {
        [key: string]: TranslationKey;
    } | TranslationKey;
    onSelect: (source: TLUiEventSource) => Promise<void> | void;
    readonlyOk?: boolean;
    title?: string;
};

/** @public */
export declare type TLUiMenuContextProviderProps = {
    children: React.ReactNode;
    sourceId: TLUiEventSource;
    type: TldrawUiMenuContextType;
};

/** @public */
export declare type TLUiMenuGroupProps<TranslationKey extends string = string> = {
    /**
     * The label to display on the item. If it's a string, it will be translated. If it's an object, the keys will be used as the language keys and the values will be translated.
     */
    label?: {
        [key: string]: TranslationKey;
    } | TranslationKey;
    children?: ReactNode;
    id: string;
};

/** @public */
export declare type TLUiMenuItemProps<TranslationKey extends string = string, IconType extends string = string> = {
    /**
     * If the editor is in readonly mode and the item is not marked as readonlyok, it will not be rendered.
     */
    readonlyOk?: boolean;
    /**
     * Prevent the menu from closing when the item is clicked
     */
    noClose?: boolean;
    /**
     * The function to call when the item is clicked.
     */
    onSelect: (source: TLUiEventSource) => Promise<void> | void;
    /**
     * The icon to display on the item.
     */
    icon?: IconType;
    /**
     * The keyboard shortcut to display on the item.
     */
    kbd?: string;
    /**
     * The label to display on the item. If it's a string, it will be translated. If it's an object, the keys will be used as the language keys and the values will be translated.
     */
    label?: {
        [key: string]: TranslationKey;
    } | TranslationKey;
    /**
     * Whether the item is selected.
     */
    isSelected?: boolean;
    /**
     * Whether this item should be disabled.
     */
    disabled?: boolean;
    /**
     * Whether to show a spinner on the item.
     */
    spinner?: boolean;
    id: string;
};

/** @public */
export declare type TLUiMenuSubmenuProps<Translation extends string = string> = {
    children: ReactNode;
    disabled?: boolean;
    id: string;
    label?: {
        [key: string]: Translation;
    } | Translation;
    size?: 'medium' | 'small' | 'tiny' | 'wide';
};

declare type TLUiOverride<Type, Helpers> = (editor: Editor, schema: Type, helpers: Helpers) => Type;

/** @public */
export declare type TLUiOverrides = Partial<{
    actions: WithDefaultHelpers<NonNullable<ActionsProviderProps['overrides']>>;
    tools: WithDefaultHelpers<NonNullable<TLUiToolsProviderProps['overrides']>>;
    translations: TLUiTranslationProviderProps['overrides'];
}>;

/** @public */
export declare type TLUiPopoverContentProps = {
    align?: 'center' | 'end' | 'start';
    alignOffset?: number;
    children: React_2.ReactNode;
    side: 'bottom' | 'left' | 'right' | 'top';
    sideOffset?: number;
};

/** @public */
export declare type TLUiPopoverProps = {
    children: React_2.ReactNode;
    id: string;
    onOpenChange?: (isOpen: boolean) => void;
    open?: boolean;
};

/** @public */
export declare interface TLUiPopoverTriggerProps {
    children?: React_2.ReactNode;
}

/** @public */
export declare type TLUiQuickActionsProps = {
    children?: ReactNode;
};

/* Excluded from this release type: TLUiSliderProps */

/** @public */
export declare type TLUiStylePanelContentProps = {
    styles: ReturnType<typeof useRelevantStyles>;
};

/** @public */
export declare interface TLUiStylePanelProps {
    isMobile?: boolean;
    children?: ReactNode;
}

/** @public */
export declare interface TLUiToast {
    id: string;
    icon?: TLUiIconType;
    severity?: AlertSeverity;
    title?: string;
    description?: string;
    actions?: TLUiToastAction[];
    keepOpen?: boolean;
    closeLabel?: string;
}

/** @public */
export declare interface TLUiToastAction {
    type: 'danger' | 'normal' | 'primary';
    label: string;
    onClick: () => void;
}

/** @public */
export declare type TLUiToastsContextType = {
    addToast: (toast: Omit<TLUiToast, 'id'> & {
        id?: string;
    }) => string;
    clearToasts: () => void;
    removeToast: (id: TLUiToast['id']) => string;
    toasts: TLUiToast[];
};

/** @public */
export declare interface TLUiToolItem<TranslationKey extends string = string, IconType extends string = string> {
    id: string;
    label: TranslationKey;
    shortcutsLabel?: TranslationKey;
    icon: IconType;
    onSelect: (source: TLUiEventSource) => void;
    kbd?: string;
    readonlyOk?: boolean;
    meta?: {
        [key: string]: any;
    };
}

/** @public */
export declare type TLUiToolsContextType = Record<string, TLUiToolItem>;

/** @public */
export declare type TLUiToolsProviderProps = {
    children: React_3.ReactNode;
    overrides?: (editor: Editor, tools: TLUiToolsContextType, helpers: {
        insertMedia: () => void;
    }) => TLUiToolsContextType;
};

/** @public */
export declare type TLUiTranslation = {
    readonly dir: 'ltr' | 'rtl';
    readonly label: string;
    readonly locale: string;
    readonly messages: Record<TLUiTranslationKey, string>;
};

/** @public */
export declare type TLUiTranslationContextType = TLUiTranslation;

/** @public */
export declare type TLUiTranslationKey = 'action.align-bottom' | 'action.align-center-horizontal.short' | 'action.align-center-horizontal' | 'action.align-center-vertical.short' | 'action.align-center-vertical' | 'action.align-left' | 'action.align-right' | 'action.align-top' | 'action.back-to-content' | 'action.bring-forward' | 'action.bring-to-front' | 'action.convert-to-bookmark' | 'action.convert-to-embed' | 'action.copy-as-json.short' | 'action.copy-as-json' | 'action.copy-as-png.short' | 'action.copy-as-png' | 'action.copy-as-svg.short' | 'action.copy-as-svg' | 'action.copy' | 'action.cut' | 'action.delete' | 'action.distribute-horizontal.short' | 'action.distribute-horizontal' | 'action.distribute-vertical.short' | 'action.distribute-vertical' | 'action.duplicate' | 'action.edit-link' | 'action.exit-pen-mode' | 'action.export-all-as-json.short' | 'action.export-all-as-json' | 'action.export-all-as-png.short' | 'action.export-all-as-png' | 'action.export-all-as-svg.short' | 'action.export-all-as-svg' | 'action.export-as-json.short' | 'action.export-as-json' | 'action.export-as-png.short' | 'action.export-as-png' | 'action.export-as-svg.short' | 'action.export-as-svg' | 'action.fit-frame-to-content' | 'action.flip-horizontal.short' | 'action.flip-horizontal' | 'action.flip-vertical.short' | 'action.flip-vertical' | 'action.fork-project' | 'action.group' | 'action.insert-embed' | 'action.insert-media' | 'action.leave-shared-project' | 'action.new-project' | 'action.new-shared-project' | 'action.open-cursor-chat' | 'action.open-embed-link' | 'action.open-file' | 'action.pack' | 'action.paste' | 'action.print' | 'action.redo' | 'action.remove-frame' | 'action.rename' | 'action.rotate-ccw' | 'action.rotate-cw' | 'action.save-copy' | 'action.select-all' | 'action.select-none' | 'action.send-backward' | 'action.send-to-back' | 'action.share-project' | 'action.stack-horizontal.short' | 'action.stack-horizontal' | 'action.stack-vertical.short' | 'action.stack-vertical' | 'action.stop-following' | 'action.stretch-horizontal.short' | 'action.stretch-horizontal' | 'action.stretch-vertical.short' | 'action.stretch-vertical' | 'action.toggle-auto-size' | 'action.toggle-dark-mode.menu' | 'action.toggle-dark-mode' | 'action.toggle-debug-mode.menu' | 'action.toggle-debug-mode' | 'action.toggle-edge-scrolling.menu' | 'action.toggle-edge-scrolling' | 'action.toggle-focus-mode.menu' | 'action.toggle-focus-mode' | 'action.toggle-grid.menu' | 'action.toggle-grid' | 'action.toggle-lock' | 'action.toggle-reduce-motion.menu' | 'action.toggle-reduce-motion' | 'action.toggle-snap-mode.menu' | 'action.toggle-snap-mode' | 'action.toggle-tool-lock.menu' | 'action.toggle-tool-lock' | 'action.toggle-transparent.context-menu' | 'action.toggle-transparent.menu' | 'action.toggle-transparent' | 'action.toggle-wrap-mode.menu' | 'action.toggle-wrap-mode' | 'action.undo' | 'action.ungroup' | 'action.unlock-all' | 'action.zoom-in' | 'action.zoom-out' | 'action.zoom-to-100' | 'action.zoom-to-fit' | 'action.zoom-to-selection' | 'actions-menu.title' | 'align-style.end' | 'align-style.justify' | 'align-style.middle' | 'align-style.start' | 'arrowheadEnd-style.arrow' | 'arrowheadEnd-style.bar' | 'arrowheadEnd-style.diamond' | 'arrowheadEnd-style.dot' | 'arrowheadEnd-style.inverted' | 'arrowheadEnd-style.none' | 'arrowheadEnd-style.pipe' | 'arrowheadEnd-style.square' | 'arrowheadEnd-style.triangle' | 'arrowheadStart-style.arrow' | 'arrowheadStart-style.bar' | 'arrowheadStart-style.diamond' | 'arrowheadStart-style.dot' | 'arrowheadStart-style.inverted' | 'arrowheadStart-style.none' | 'arrowheadStart-style.pipe' | 'arrowheadStart-style.square' | 'arrowheadStart-style.triangle' | 'assets.files.upload-failed' | 'assets.url.failed' | 'color-style.black' | 'color-style.blue' | 'color-style.green' | 'color-style.grey' | 'color-style.light-blue' | 'color-style.light-green' | 'color-style.light-red' | 'color-style.light-violet' | 'color-style.orange' | 'color-style.red' | 'color-style.violet' | 'color-style.white' | 'color-style.yellow' | 'context-menu.arrange' | 'context-menu.copy-as' | 'context-menu.export-all-as' | 'context-menu.export-as' | 'context-menu.move-to-page' | 'context-menu.reorder' | 'context.pages.new-page' | 'cursor-chat.type-to-chat' | 'dash-style.dashed' | 'dash-style.dotted' | 'dash-style.draw' | 'dash-style.solid' | 'debug-panel.more' | 'document.default-name' | 'edit-link-dialog.cancel' | 'edit-link-dialog.clear' | 'edit-link-dialog.detail' | 'edit-link-dialog.invalid-url' | 'edit-link-dialog.save' | 'edit-link-dialog.title' | 'edit-link-dialog.url' | 'edit-pages-dialog.move-down' | 'edit-pages-dialog.move-up' | 'embed-dialog.back' | 'embed-dialog.cancel' | 'embed-dialog.create' | 'embed-dialog.instruction' | 'embed-dialog.invalid-url' | 'embed-dialog.title' | 'embed-dialog.url' | 'file-system.confirm-clear.cancel' | 'file-system.confirm-clear.continue' | 'file-system.confirm-clear.description' | 'file-system.confirm-clear.dont-show-again' | 'file-system.confirm-clear.title' | 'file-system.confirm-open.cancel' | 'file-system.confirm-open.description' | 'file-system.confirm-open.dont-show-again' | 'file-system.confirm-open.open' | 'file-system.confirm-open.title' | 'file-system.file-open-error.file-format-version-too-new' | 'file-system.file-open-error.generic-corrupted-file' | 'file-system.file-open-error.not-a-tldraw-file' | 'file-system.file-open-error.title' | 'file-system.shared-document-file-open-error.description' | 'file-system.shared-document-file-open-error.title' | 'fill-style.none' | 'fill-style.pattern' | 'fill-style.semi' | 'fill-style.solid' | 'focus-mode.toggle-focus-mode' | 'font-style.draw' | 'font-style.mono' | 'font-style.sans' | 'font-style.serif' | 'geo-style.arrow-down' | 'geo-style.arrow-left' | 'geo-style.arrow-right' | 'geo-style.arrow-up' | 'geo-style.check-box' | 'geo-style.cloud' | 'geo-style.diamond' | 'geo-style.ellipse' | 'geo-style.hexagon' | 'geo-style.octagon' | 'geo-style.oval' | 'geo-style.pentagon' | 'geo-style.rectangle' | 'geo-style.rhombus-2' | 'geo-style.rhombus' | 'geo-style.star' | 'geo-style.trapezoid' | 'geo-style.triangle' | 'geo-style.x-box' | 'help-menu.about' | 'help-menu.discord' | 'help-menu.github' | 'help-menu.keyboard-shortcuts' | 'help-menu.title' | 'help-menu.twitter' | 'home-project-dialog.description' | 'home-project-dialog.ok' | 'home-project-dialog.title' | 'menu.copy-as' | 'menu.edit' | 'menu.export-as' | 'menu.file' | 'menu.language' | 'menu.preferences' | 'menu.title' | 'menu.view' | 'navigation-zone.toggle-minimap' | 'navigation-zone.zoom' | 'opacity-style.0.1' | 'opacity-style.0.25' | 'opacity-style.0.5' | 'opacity-style.0.75' | 'opacity-style.1' | 'page-menu.create-new-page' | 'page-menu.edit-done' | 'page-menu.edit-start' | 'page-menu.go-to-page' | 'page-menu.max-page-count-reached' | 'page-menu.new-page-initial-name' | 'page-menu.submenu.delete' | 'page-menu.submenu.duplicate-page' | 'page-menu.submenu.move-down' | 'page-menu.submenu.move-up' | 'page-menu.submenu.rename' | 'page-menu.submenu.title' | 'page-menu.title' | 'people-menu.change-color' | 'people-menu.change-name' | 'people-menu.follow' | 'people-menu.following' | 'people-menu.invite' | 'people-menu.leading' | 'people-menu.title' | 'people-menu.user' | 'rename-project-dialog.cancel' | 'rename-project-dialog.rename' | 'rename-project-dialog.title' | 'share-menu.copy-link-note' | 'share-menu.copy-link' | 'share-menu.copy-readonly-link-note' | 'share-menu.copy-readonly-link' | 'share-menu.create-snapshot-link' | 'share-menu.default-project-name' | 'share-menu.fork-note' | 'share-menu.offline-note' | 'share-menu.project-too-large' | 'share-menu.readonly-link' | 'share-menu.save-note' | 'share-menu.share-project' | 'share-menu.snapshot-link-note' | 'share-menu.title' | 'share-menu.upload-failed' | 'sharing.confirm-leave.cancel' | 'sharing.confirm-leave.description' | 'sharing.confirm-leave.dont-show-again' | 'sharing.confirm-leave.leave' | 'sharing.confirm-leave.title' | 'shortcuts-dialog.collaboration' | 'shortcuts-dialog.edit' | 'shortcuts-dialog.file' | 'shortcuts-dialog.preferences' | 'shortcuts-dialog.title' | 'shortcuts-dialog.tools' | 'shortcuts-dialog.transform' | 'shortcuts-dialog.view' | 'size-style.l' | 'size-style.m' | 'size-style.s' | 'size-style.xl' | 'spline-style.cubic' | 'spline-style.line' | 'status.offline' | 'status.online' | 'style-panel.align' | 'style-panel.arrowhead-end' | 'style-panel.arrowhead-start' | 'style-panel.arrowheads' | 'style-panel.color' | 'style-panel.dash' | 'style-panel.fill' | 'style-panel.font' | 'style-panel.geo' | 'style-panel.mixed' | 'style-panel.opacity' | 'style-panel.position' | 'style-panel.size' | 'style-panel.spline' | 'style-panel.title' | 'style-panel.vertical-align' | 'toast.close' | 'toast.error.copy-fail.desc' | 'toast.error.copy-fail.title' | 'toast.error.export-fail.desc' | 'toast.error.export-fail.title' | 'tool-panel.drawing' | 'tool-panel.more' | 'tool-panel.shapes' | 'tool.arrow-down' | 'tool.arrow-left' | 'tool.arrow-right' | 'tool.arrow-up' | 'tool.arrow' | 'tool.asset' | 'tool.check-box' | 'tool.cloud' | 'tool.diamond' | 'tool.draw' | 'tool.ellipse' | 'tool.embed' | 'tool.eraser' | 'tool.frame' | 'tool.hand' | 'tool.hexagon' | 'tool.highlight' | 'tool.laser' | 'tool.line' | 'tool.note' | 'tool.octagon' | 'tool.oval' | 'tool.pentagon' | 'tool.rectangle' | 'tool.rhombus' | 'tool.select' | 'tool.star' | 'tool.text' | 'tool.trapezoid' | 'tool.triangle' | 'tool.x-box' | 'verticalAlign-style.end' | 'verticalAlign-style.middle' | 'verticalAlign-style.start' | 'vscode.file-open.backup-failed' | 'vscode.file-open.backup-saved' | 'vscode.file-open.backup' | 'vscode.file-open.desc' | 'vscode.file-open.dont-show-again' | 'vscode.file-open.open';

/** @public */
declare interface TLUiTranslationProviderProps {
    children: React_3.ReactNode;
    /**
     * A collection of overrides different locales.
     *
     * @example
     *
     * ```ts
     * <TranslationProvider overrides={{ en: { 'style-panel.styles': 'Properties' } }} />
     * ```
     */
    overrides?: Record<string, Record<string, string>>;
}

/** @public */
export declare type TLUiZoomMenuProps = {
    children?: ReactNode;
};

declare interface TLV1Asset {
    id: string;
    type: string;
}

declare interface TLV1Binding {
    id: string;
    toId: string;
    fromId: string;
}

declare interface TLV1Bounds {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    width: number;
    height: number;
    rotation?: number;
}

declare interface TLV1Handle {
    id: string;
    index: number;
    point: number[];
}

declare interface TLV1PageState {
    id: string;
    selectedIds: string[];
    camera: {
        point: number[];
        zoom: number;
    };
    brush?: null | TLV1Bounds;
    pointedId?: null | string;
    hoveredId?: null | string;
    editingId?: null | string;
    bindingId?: null | string;
}

declare interface TLV1Shape {
    id: string;
    type: string;
    parentId: string;
    childIndex: number;
    name: string;
    point: number[];
    assetId?: string;
    rotation?: number;
    children?: string[];
    handles?: Record<string, TLV1Handle>;
    isGhost?: boolean;
    isHidden?: boolean;
    isLocked?: boolean;
    isGenerated?: boolean;
    isAspectRatioLocked?: boolean;
}

/** @public */
export declare function ToggleAutoSizeMenuItem(): JSX_2.Element | null;

/** @public */
export declare function ToggleDarkModeItem(): JSX_2.Element;

/** @public */
export declare function ToggleDebugModeItem(): JSX_2.Element;

/** @public */
export declare function ToggleEdgeScrollingItem(): JSX_2.Element;

/** @public */
export declare function ToggleFocusModeItem(): JSX_2.Element;

/** @public */
export declare function ToggleGridItem(): JSX_2.Element;

/** @public */
export declare function ToggleLockMenuItem(): JSX_2.Element | null;

/** @public */
export declare function ToggleReduceMotionItem(): JSX_2.Element;

/** @public */
export declare function ToggleSnapModeItem(): JSX_2.Element;

/** @public */
export declare function ToggleToolLockItem(): JSX_2.Element;

/** @public */
export declare function ToggleTransparentBgMenuItem(): JSX_2.Element;

/** @public */
export declare function ToggleWrapModeItem(): JSX_2.Element;

declare class Translating extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        shape: TLShape;
        target: "shape";
    } & {
        didStartInPit?: boolean | undefined;
        isCreating?: boolean | undefined;
        onCreate?: (() => void) | undefined;
        onInteractionEnd?: string | undefined;
        target: 'shape';
    };
    selectionSnapshot: TranslatingSnapshot;
    snapshot: TranslatingSnapshot;
    markId: string;
    isCloning: boolean;
    isCreating: boolean;
    onCreate: (shape: null | TLShape) => void;
    dragAndDropManager: DragAndDropManager;
    onEnter: (info: TLPointerEventInfo & {
        isCreating?: boolean;
        onCreate?: () => void;
        onInteractionEnd?: string;
        target: 'shape';
    }) => void;
    onExit: () => void;
    onTick: () => void;
    onPointerMove: () => void;
    onKeyDown: () => void;
    onKeyUp: TLEventHandlers['onKeyUp'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    protected startCloning(): void;
    protected stopCloning(): void;
    reset(): void;
    protected complete(): void;
    private cancel;
    protected handleStart(): void;
    protected handleEnd(): void;
    protected handleChange(): void;
    protected updateShapes(): void;
    protected updateParentTransforms: () => void;
}

declare class TranslatingCrop extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        button: number;
        isPen: boolean;
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        type: "pointer";
    } & {
        shape: TLShape;
        target: "shape";
    } & {
        isCreating?: boolean | undefined;
        onInteractionEnd?: string | undefined;
        target: 'shape';
    };
    markId: string;
    private snapshot;
    onEnter: (info: TLPointerEventInfo & {
        isCreating?: boolean;
        onInteractionEnd?: string;
        target: 'shape';
    }) => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyUp: TLEventHandlers['onKeyUp'];
    protected complete(): void;
    private cancel;
    private createSnapshot;
    protected updateShapes(): void;
}

declare type TranslatingSnapshot = ReturnType<typeof getTranslatingSnapshot>;

/** @public */
export declare function TrapezoidToolbarItem(): JSX_2.Element;

declare interface TriangleShape extends TDBaseShape {
    type: TDShapeType.Triangle;
    size: number[];
    label?: string;
    labelPoint?: number[];
}

/** @public */
export declare function TriangleToolbarItem(): JSX_2.Element;

/** @public */
export declare const truncateStringWithEllipsis: (str: string, maxLength: number) => string;

/** @public */
export declare function UiEventsProvider({ onEvent, children }: EventsProviderProps): JSX_2.Element;

/** @public */
export declare function UndoRedoGroup(): JSX_2.Element;

/** @public */
export declare function UngroupMenuItem(): JSX_2.Element | null;

/** @public */
export declare function UnlockAllMenuItem(): JSX_2.Element;

/** @public */
export declare function unwrapLabel(label?: TLUiActionItem['label'], menuType?: string): string | undefined;

/** @public */
export declare function useActions(): TLUiActionsContextType;

/* Excluded from this release type: useAssetUrls */

/** @public */
export declare function useBreakpoint(): number;

/** @public */
export declare function useCanRedo(): boolean;

/** @public */
export declare function useCanUndo(): boolean;

/** @public */
export declare function useCopyAs(): (ids: TLShapeId[], format?: TLCopyType) => void;

/** @public */
export declare const useCurrentTranslation: () => TLUiTranslation;

/** @public */
export declare function useDefaultColorTheme(): {
    "light-blue": TLDefaultColorThemeColor;
    "light-green": TLDefaultColorThemeColor;
    "light-red": TLDefaultColorThemeColor;
    "light-violet": TLDefaultColorThemeColor;
    background: string;
    black: TLDefaultColorThemeColor;
    blue: TLDefaultColorThemeColor;
    green: TLDefaultColorThemeColor;
    grey: TLDefaultColorThemeColor;
    id: "dark" | "light";
    orange: TLDefaultColorThemeColor;
    red: TLDefaultColorThemeColor;
    solid: string;
    text: string;
    violet: TLDefaultColorThemeColor;
    white: TLDefaultColorThemeColor;
    yellow: TLDefaultColorThemeColor;
};

/** @public */
export declare function useDefaultHelpers(): {
    addDialog: (dialog: Omit<TLUiDialog, "id"> & {
        id?: string | undefined;
    }) => string;
    addToast: (toast: Omit<TLUiToast, "id"> & {
        id?: string | undefined;
    }) => string;
    clearDialogs: () => void;
    clearToasts: () => void;
    isMobile: boolean;
    msg: (id?: string | undefined) => string;
    removeDialog: (id: string) => string;
    removeToast: (id: string) => string;
    updateDialog: (id: string, newDialogData: Partial<TLUiDialog>) => string;
};

/** @public */
export declare function useDialogs(): TLUiDialogsContextType;

/** @public */
export declare function useEditableText(id: TLShapeId, type: string, text: string): {
    handleBlur: () => void;
    handleChange: (e: React_2.ChangeEvent<HTMLTextAreaElement>) => void;
    handleDoubleClick: (e: any) => any;
    handleFocus: typeof noop;
    handleInputPointerDown: (e: React_2.PointerEvent) => void;
    handleKeyDown: (e: React_2.KeyboardEvent<HTMLTextAreaElement>) => void;
    isEditing: boolean;
    isEditingAnything: boolean;
    isEmpty: boolean;
    rInput: React_2.RefObject<HTMLTextAreaElement>;
};

/** @public */
export declare function useExportAs(): (ids: TLShapeId[], format: TLExportType | undefined, name: string | undefined) => void;

/** @public */
export declare function useIsToolSelected(tool: TLUiToolItem): boolean;

/** @public */
export declare function useKeyboardShortcuts(): void;

/** @public */
export declare function useLocalStorageState<T = any>(key: string, defaultValue: T): readonly [T, (setter: ((value: T) => T) | T) => void];

/** @public */
export declare function useMenuClipboardEvents(): {
    copy: (source: TLUiEventSource) => void;
    cut: (source: TLUiEventSource) => void;
    paste: (data: ClipboardItem[] | DataTransfer, source: TLUiEventSource, point?: VecLike) => Promise<void>;
};

/** @public */
export declare function useMenuIsOpen(id: string, cb?: (isOpen: boolean) => void): readonly [boolean, (isOpen: boolean) => void];

/** @public */
export declare function useNativeClipboardEvents(): void;

/** @public */
export declare function usePreloadAssets(assetUrls: TLEditorAssetUrls): {
    done: boolean;
    error: boolean;
};

/** @public */
export declare function useReadonly(): boolean;

/** @public */
export declare function useRelevantStyles(stylesToCheck?: readonly StyleProp<any>[]): null | ReadonlySharedStyleMap;

/** @public */
export declare function useTldrawUiComponents(): Partial<{
    ActionsMenu: ComponentType<TLUiActionsMenuProps> | null;
    ContextMenu: ComponentType<TLUiContextMenuProps> | null;
    DebugMenu: ComponentType | null;
    DebugPanel: ComponentType | null;
    HelperButtons: ComponentType<TLUiHelperButtonsProps> | null;
    HelpMenu: ComponentType<TLUiHelpMenuProps> | null;
    KeyboardShortcutsDialog: ComponentType<TLUiKeyboardShortcutsDialogProps> | null;
    MainMenu: ComponentType<TLUiMainMenuProps> | null;
    MenuPanel: ComponentType | null;
    Minimap: ComponentType | null;
    NavigationPanel: ComponentType | null;
    PageMenu: ComponentType | null;
    QuickActions: ComponentType<TLUiQuickActionsProps> | null;
    SharePanel: ComponentType | null;
    StylePanel: ComponentType<TLUiStylePanelProps> | null;
    Toolbar: ComponentType | null;
    TopPanel: ComponentType | null;
    ZoomMenu: ComponentType<TLUiZoomMenuProps> | null;
}>;

/** @public */
export declare function useToasts(): TLUiToastsContextType;

/** @public */
export declare function useTools(): TLUiToolsContextType;

/**
 * Returns a function to translate a translation key into a string based on the current translation.
 *
 * @example
 *
 * ```ts
 * const msg = useTranslation()
 * const label = msg('style-panel.styles')
 * ```
 *
 * @public
 */
export declare function useTranslation(): (id?: Exclude<string, TLUiTranslationKey> | string) => string;

/** @public */
export declare function useUiEvents(): TLUiEventContextType;

declare interface VideoShape extends TDBaseShape {
    type: TDShapeType.Video;
    size: number[];
    assetId: string;
    isPlaying: boolean;
    currentTime: number;
}

/** @public */
export declare class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
    static type: "video";
    static props: {
        assetId: Validator<TLAssetId | null>;
        h: Validator<number>;
        playing: Validator<boolean>;
        time: Validator<number>;
        url: Validator<string>;
        w: Validator<number>;
    };
    static migrations: TLShapePropsMigrations;
    canEdit: () => boolean;
    isAspectRatioLocked: () => boolean;
    getDefaultProps(): TLVideoShape['props'];
    component(shape: TLVideoShape): JSX_2.Element;
    indicator(shape: TLVideoShape): JSX_2.Element;
    toSvg(shape: TLVideoShape): JSX_2.Element;
}

/** @public */
export declare function ViewSubmenu(): JSX_2.Element;

declare type WithDefaultHelpers<T extends TLUiOverride<any, any>> = T extends TLUiOverride<infer Type, infer Helpers> ? TLUiOverride<Type, Helpers extends undefined ? DefaultHelpers : Helpers & DefaultHelpers> : never;

/** @public */
export declare function XBoxToolbarItem(): JSX_2.Element;

declare class ZoomBrushing extends StateNode {
    static id: string;
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    zoomBrush: Box;
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    private update;
    private cancel;
    private complete;
}

/** @public */
export declare function ZoomOrRotateMenuItem(): JSX_2.Element;

/** @public */
export declare function ZoomTo100MenuItem(): JSX_2.Element;

/** @public */
export declare function ZoomToFitMenuItem(): JSX_2.Element;

/** @public */
export declare class ZoomTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_12 | typeof Pointing_8 | typeof ZoomBrushing)[];
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    onExit: () => void;
    onKeyDown: TLKeyboardEvent | undefined;
    onKeyUp: TLKeyboardEvent;
    onInterrupt: TLInterruptEvent;
    private complete;
    private updateCursor;
}

/** @public */
export declare function ZoomToSelectionMenuItem(): JSX_2.Element;


export * from "@tldraw/editor";

export { }
