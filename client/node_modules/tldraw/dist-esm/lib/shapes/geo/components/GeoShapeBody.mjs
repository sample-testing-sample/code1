import { jsx } from "react/jsx-runtime";
import { Group2d, useEditor } from "@tldraw/editor";
import { STROKE_SIZES } from "../../shared/default-shape-constants.mjs";
import { getLines } from "../getLines.mjs";
import { DashStyleCloud } from "./DashStyleCloud.mjs";
import { DashStyleEllipse } from "./DashStyleEllipse.mjs";
import { DashStyleOval } from "./DashStyleOval.mjs";
import { DashStylePolygon } from "./DashStylePolygon.mjs";
import { DrawStyleCloud } from "./DrawStyleCloud.mjs";
import { DrawStylePolygon } from "./DrawStylePolygon.mjs";
import { SolidStyleCloud } from "./SolidStyleCloud.mjs";
import { SolidStyleEllipse } from "./SolidStyleEllipse.mjs";
import { SolidStyleOval } from "./SolidStyleOval.mjs";
import { SolidStylePolygon } from "./SolidStylePolygon.mjs";
function GeoShapeBody({ shape }) {
  const editor = useEditor();
  const { id, props } = shape;
  const { w, color, fill, dash, growY, size } = props;
  const strokeWidth = STROKE_SIZES[size];
  const h = props.h + growY;
  switch (props.geo) {
    case "cloud": {
      if (dash === "solid") {
        return /* @__PURE__ */ jsx(
          SolidStyleCloud,
          {
            color,
            fill,
            strokeWidth,
            w,
            h,
            id,
            size
          }
        );
      } else if (dash === "dashed" || dash === "dotted") {
        return /* @__PURE__ */ jsx(
          DashStyleCloud,
          {
            color,
            fill,
            strokeWidth,
            w,
            h,
            id,
            size,
            dash
          }
        );
      } else if (dash === "draw") {
        return /* @__PURE__ */ jsx(
          DrawStyleCloud,
          {
            color,
            fill,
            strokeWidth,
            w,
            h,
            id,
            size
          }
        );
      }
      break;
    }
    case "ellipse": {
      if (dash === "solid") {
        return /* @__PURE__ */ jsx(SolidStyleEllipse, { strokeWidth, w, h, color, fill });
      } else if (dash === "dashed" || dash === "dotted") {
        return /* @__PURE__ */ jsx(
          DashStyleEllipse,
          {
            id,
            strokeWidth,
            w,
            h,
            dash,
            color,
            fill
          }
        );
      } else if (dash === "draw") {
        return /* @__PURE__ */ jsx(SolidStyleEllipse, { strokeWidth, w, h, color, fill });
      }
      break;
    }
    case "oval": {
      if (dash === "solid") {
        return /* @__PURE__ */ jsx(SolidStyleOval, { strokeWidth, w, h, color, fill });
      } else if (dash === "dashed" || dash === "dotted") {
        return /* @__PURE__ */ jsx(
          DashStyleOval,
          {
            id,
            strokeWidth,
            w,
            h,
            dash,
            color,
            fill
          }
        );
      } else if (dash === "draw") {
        return /* @__PURE__ */ jsx(SolidStyleOval, { strokeWidth, w, h, color, fill });
      }
      break;
    }
    default: {
      const geometry = editor.getShapeGeometry(shape);
      const outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices;
      const lines = getLines(shape.props, strokeWidth);
      if (dash === "solid") {
        return /* @__PURE__ */ jsx(
          SolidStylePolygon,
          {
            fill,
            color,
            strokeWidth,
            outline,
            lines
          }
        );
      } else if (dash === "dashed" || dash === "dotted") {
        return /* @__PURE__ */ jsx(
          DashStylePolygon,
          {
            dash,
            fill,
            color,
            strokeWidth,
            outline,
            lines
          }
        );
      } else if (dash === "draw") {
        return /* @__PURE__ */ jsx(
          DrawStylePolygon,
          {
            id,
            fill,
            color,
            strokeWidth,
            outline,
            lines
          }
        );
      }
    }
  }
}
export {
  GeoShapeBody
};
//# sourceMappingURL=GeoShapeBody.mjs.map
