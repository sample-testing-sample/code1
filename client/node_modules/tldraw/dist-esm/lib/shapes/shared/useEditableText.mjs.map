{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/shared/useEditableText.ts"],
  "sourcesContent": ["import {\n\tTLShapeId,\n\tTLUnknownShape,\n\tgetPointerInfo,\n\tstopEventPropagation,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport React, { useCallback, useEffect, useRef } from 'react'\nimport { INDENT, TextHelpers } from './TextHelpers'\n\n/** @public */\nexport function useEditableText(id: TLShapeId, type: string, text: string) {\n\tconst editor = useEditor()\n\tconst rInput = useRef<HTMLTextAreaElement>(null)\n\tconst rSelectionRanges = useRef<Range[] | null>()\n\tconst isEditing = useValue('isEditing', () => editor.getEditingShapeId() === id, [editor])\n\tconst isEditingAnything = useValue('isEditingAnything', () => !!editor.getEditingShapeId(), [\n\t\teditor,\n\t])\n\n\tuseEffect(() => {\n\t\tfunction selectAllIfEditing({ shapeId }: { shapeId: TLShapeId }) {\n\t\t\t// We wait a tick, because on iOS, the keyboard will not show if we focus immediately.\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tif (shapeId === id) {\n\t\t\t\t\tconst elm = rInput.current\n\t\t\t\t\tif (elm) {\n\t\t\t\t\t\tif (document.activeElement !== elm) {\n\t\t\t\t\t\t\telm.focus()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telm.select()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\teditor.on('select-all-text', selectAllIfEditing)\n\t\treturn () => {\n\t\t\teditor.off('select-all-text', selectAllIfEditing)\n\t\t}\n\t}, [editor, id])\n\n\tuseEffect(() => {\n\t\tif (!isEditing) return\n\n\t\tconst elm = rInput.current\n\t\tif (!elm) return\n\n\t\t// Focus if we're not already focused\n\t\tif (document.activeElement !== elm) {\n\t\t\telm.focus()\n\n\t\t\t// On mobile etc, just select all the text when we start focusing\n\t\t\tif (editor.getInstanceState().isCoarsePointer) {\n\t\t\t\telm.select()\n\t\t\t}\n\t\t} else {\n\t\t\t// This fixes iOS not showing the cursor sometimes. This \"shakes\" the cursor\n\t\t\t// awake.\n\t\t\tif (editor.environment.isSafari) {\n\t\t\t\telm.blur()\n\t\t\t\telm.focus()\n\t\t\t}\n\t\t}\n\n\t\t// When the selection changes, save the selection ranges\n\t\tfunction updateSelection() {\n\t\t\tconst selection = window.getSelection?.()\n\t\t\tif (selection && selection.type !== 'None') {\n\t\t\t\tconst ranges: Range[] = []\n\t\t\t\tfor (let i = 0; i < selection.rangeCount; i++) {\n\t\t\t\t\tranges.push(selection.getRangeAt?.(i))\n\t\t\t\t}\n\t\t\t\trSelectionRanges.current = ranges\n\t\t\t}\n\t\t}\n\n\t\tdocument.addEventListener('selectionchange', updateSelection)\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('selectionchange', updateSelection)\n\t\t}\n\t}, [editor, isEditing])\n\n\t// 2. Restore the selection changes (and focus) if the element blurs\n\t// When the label blurs, deselect all of the text and complete.\n\t// This makes it so that the canvas does not have to be focused\n\t// in order to exit the editing state and complete the editing state\n\tconst handleBlur = useCallback(() => {\n\t\tconst ranges = rSelectionRanges.current\n\n\t\trequestAnimationFrame(() => {\n\t\t\tconst elm = rInput.current\n\t\t\tconst editingShapeId = editor.getEditingShapeId()\n\n\t\t\t// Did we move to a different shape?\n\t\t\tif (editingShapeId) {\n\t\t\t\t// important! these ^v are two different things\n\t\t\t\t// is that shape OUR shape?\n\t\t\t\tif (elm && editingShapeId === id) {\n\t\t\t\t\telm.focus()\n\n\t\t\t\t\tif (ranges && ranges.length) {\n\t\t\t\t\t\tconst selection = window.getSelection()\n\t\t\t\t\t\tif (selection) {\n\t\t\t\t\t\t\tranges.forEach((range) => selection.addRange(range))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twindow.getSelection()?.removeAllRanges()\n\t\t\t}\n\t\t})\n\t}, [editor, id])\n\n\t// When the user presses ctrl / meta enter, complete the editing state.\n\tconst handleKeyDown = useCallback(\n\t\t(e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n\t\t\tif (editor.getEditingShapeId() !== id) return\n\n\t\t\tswitch (e.key) {\n\t\t\t\tcase 'Enter': {\n\t\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\t\teditor.complete()\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[editor, id]\n\t)\n\n\t// When the text changes, update the text value.\n\tconst handleChange = useCallback(\n\t\t(e: React.ChangeEvent<HTMLTextAreaElement>) => {\n\t\t\tif (editor.getEditingShapeId() !== id) return\n\n\t\t\tlet text = TextHelpers.normalizeText(e.currentTarget.value)\n\n\t\t\t// ------- Bug fix ------------\n\t\t\t// Replace tabs with spaces when pasting\n\t\t\tconst untabbedText = text.replace(/\\t/g, INDENT)\n\t\t\tif (untabbedText !== text) {\n\t\t\t\tconst selectionStart = e.currentTarget.selectionStart\n\t\t\t\te.currentTarget.value = untabbedText\n\t\t\t\te.currentTarget.selectionStart = selectionStart + (untabbedText.length - text.length)\n\t\t\t\te.currentTarget.selectionEnd = selectionStart + (untabbedText.length - text.length)\n\t\t\t\ttext = untabbedText\n\t\t\t}\n\t\t\t// ----------------------------\n\n\t\t\teditor.updateShape<TLUnknownShape & { props: { text: string } }>({\n\t\t\t\tid,\n\t\t\t\ttype,\n\t\t\t\tprops: { text },\n\t\t\t})\n\t\t},\n\t\t[editor, id, type]\n\t)\n\n\tconst handleInputPointerDown = useCallback(\n\t\t(e: React.PointerEvent) => {\n\t\t\t// N.B. We used to only do this only when isEditing to help\n\t\t\t// prevent an issue where you could drag a selected shape\n\t\t\t// behind another shape. That is addressed now by the CSS logic\n\t\t\t// looking at data-isselectinganything.\n\t\t\t//\n\t\t\t// We still need to follow this logic even if not isEditing\n\t\t\t// because otherwise there is some flakiness in selection.\n\t\t\t// When selecting text, it would sometimes select some text\n\t\t\t// partially if we didn't dispatch/stop below.\n\n\t\t\teditor.dispatch({\n\t\t\t\t...getPointerInfo(e),\n\t\t\t\ttype: 'pointer',\n\t\t\t\tname: 'pointer_down',\n\t\t\t\ttarget: 'shape',\n\t\t\t\tshape: editor.getShape(id)!,\n\t\t\t})\n\n\t\t\tstopEventPropagation(e) // we need to prevent blurring the input\n\t\t},\n\t\t[editor, id]\n\t)\n\n\treturn {\n\t\trInput,\n\t\thandleFocus: noop,\n\t\thandleBlur,\n\t\thandleKeyDown,\n\t\thandleChange,\n\t\thandleInputPointerDown,\n\t\thandleDoubleClick: stopEventPropagation,\n\t\tisEmpty: text.trim().length === 0,\n\t\tisEditing,\n\t\tisEditingAnything,\n\t}\n}\n\nfunction noop() {\n\treturn\n}\n"],
  "mappings": "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",
  "names": ["text"]
}
