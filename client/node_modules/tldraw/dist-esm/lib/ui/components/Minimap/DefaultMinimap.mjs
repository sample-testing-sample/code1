import { jsx } from "react/jsx-runtime";
import {
  ANIMATION_MEDIUM_MS,
  Vec,
  getPointerInfo,
  normalizeWheel,
  releasePointerCapture,
  setPointerCapture,
  useEditor,
  useIsDarkMode
} from "@tldraw/editor";
import * as React from "react";
import { MinimapManager } from "./MinimapManager.mjs";
function DefaultMinimap() {
  const editor = useEditor();
  const rCanvas = React.useRef(null);
  const rPointing = React.useRef(false);
  const minimapRef = React.useRef();
  React.useEffect(() => {
    const minimap = new MinimapManager(editor, rCanvas.current);
    minimapRef.current = minimap;
    return minimapRef.current.close;
  }, [editor]);
  const onDoubleClick = React.useCallback(
    (e) => {
      if (!editor.getCurrentPageShapeIds().size)
        return;
      if (!minimapRef.current)
        return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        true
      );
      minimapRef.current.originPagePoint.setTo(clampedPoint);
      minimapRef.current.originPageCenter.setTo(editor.getViewportPageBounds().center);
      editor.centerOnPoint(point, { duration: ANIMATION_MEDIUM_MS });
    },
    [editor]
  );
  const onPointerDown = React.useCallback(
    (e) => {
      if (!minimapRef.current)
        return;
      const elm = e.currentTarget;
      setPointerCapture(elm, e);
      if (!editor.getCurrentPageShapeIds().size)
        return;
      rPointing.current = true;
      minimapRef.current.isInViewport = false;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        true
      );
      const _vpPageBounds = editor.getViewportPageBounds();
      minimapRef.current.isInViewport = _vpPageBounds.containsPoint(clampedPoint);
      if (minimapRef.current.isInViewport) {
        minimapRef.current.originPagePoint.setTo(clampedPoint);
        minimapRef.current.originPageCenter.setTo(_vpPageBounds.center);
      } else {
        const delta = Vec.Sub(_vpPageBounds.center, _vpPageBounds.point);
        const pagePoint = Vec.Add(point, delta);
        minimapRef.current.originPagePoint.setTo(pagePoint);
        minimapRef.current.originPageCenter.setTo(point);
        editor.centerOnPoint(point, { duration: ANIMATION_MEDIUM_MS });
      }
      function release(e2) {
        if (elm) {
          releasePointerCapture(elm, e2);
        }
        rPointing.current = false;
        document.body.removeEventListener("pointerup", release);
      }
      document.body.addEventListener("pointerup", release);
    },
    [editor]
  );
  const onPointerMove = React.useCallback(
    (e) => {
      if (!minimapRef.current)
        return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        e.shiftKey,
        true
      );
      if (rPointing.current) {
        if (minimapRef.current.isInViewport) {
          const delta = minimapRef.current.originPagePoint.clone().sub(minimapRef.current.originPageCenter);
          editor.centerOnPoint(Vec.Sub(point, delta));
          return;
        }
        editor.centerOnPoint(point);
      }
      const pagePoint = minimapRef.current.getMinimapPagePoint(e.clientX, e.clientY);
      const screenPoint = editor.pageToScreen(pagePoint);
      const info = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...getPointerInfo(e),
        point: screenPoint,
        isPen: editor.getInstanceState().isPenMode
      };
      editor.dispatch(info);
    },
    [editor]
  );
  const onWheel = React.useCallback(
    (e) => {
      const offset = normalizeWheel(e);
      editor.dispatch({
        type: "wheel",
        name: "wheel",
        delta: offset,
        point: new Vec(e.clientX, e.clientY),
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey
      });
    },
    [editor]
  );
  const isDarkMode = useIsDarkMode();
  React.useEffect(() => {
    setTimeout(() => {
      minimapRef.current?.updateColors();
      minimapRef.current?.render();
    });
  }, [isDarkMode]);
  return /* @__PURE__ */ jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ jsx(
    "canvas",
    {
      role: "img",
      "aria-label": "minimap",
      ref: rCanvas,
      className: "tlui-minimap__canvas",
      onDoubleClick,
      onPointerMove,
      onPointerDown,
      onWheel
    }
  ) });
}
export {
  DefaultMinimap
};
//# sourceMappingURL=DefaultMinimap.mjs.map
