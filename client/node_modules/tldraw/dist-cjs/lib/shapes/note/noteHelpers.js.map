{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/note/noteHelpers.ts"],
  "sourcesContent": ["import { Editor, IndexKey, TLNoteShape, TLShape, Vec, compact, createShapeId } from '@tldraw/editor'\nimport { zoomToShapeIfOffscreen } from '../../tools/SelectTool/selectHelpers'\n\n/** @internal */\nexport const ADJACENT_NOTE_MARGIN = 20\n/** @internal */\nexport const CLONE_HANDLE_MARGIN = 0\n/** @internal */\nexport const NOTE_SIZE = 200\n/** @internal */\nexport const NOTE_CENTER_OFFSET = { x: NOTE_SIZE / 2, y: NOTE_SIZE / 2 }\n/** @internal */\nexport const NOTE_PIT_RADIUS = 10\n\nconst DEFAULT_PITS = {\n\t['a1' as IndexKey]: new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * -0.5 - ADJACENT_NOTE_MARGIN), // t\n\t['a2' as IndexKey]: new Vec(NOTE_SIZE * 1.5 + ADJACENT_NOTE_MARGIN, NOTE_SIZE * 0.5), // r\n\t['a3' as IndexKey]: new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * 1.5 + ADJACENT_NOTE_MARGIN), // b\n\t['a4' as IndexKey]: new Vec(NOTE_SIZE * -0.5 - ADJACENT_NOTE_MARGIN, NOTE_SIZE * 0.5), // l\n}\n\n/**\n * Get the adjacent positions for a particular note shape.\n *\n * @param pagePoint - The point of the note shape on the page.\n * @param pageRotation - The rotation of the note shape on the page.\n * @param growY - The growY of the note shape.\n * @param extraHeight - The extra height to add to the top position above the note shape (ie the growY of the dragging shape).\n *\n * @internal */\nexport function getNoteAdjacentPositions(\n\tpagePoint: Vec,\n\tpageRotation: number,\n\tgrowY: number,\n\textraHeight: number\n): Record<IndexKey, Vec> {\n\treturn Object.fromEntries(\n\t\tObject.entries(DEFAULT_PITS).map(([id, v], i) => {\n\t\t\tconst point = v.clone()\n\t\t\tif (i === 0 && extraHeight) {\n\t\t\t\t// apply top margin (the growY of the moving note shape)\n\t\t\t\tpoint.y -= extraHeight\n\t\t\t} else if (i === 2 && growY) {\n\t\t\t\t// apply bottom margin (the growY of this note shape)\n\t\t\t\tpoint.y += growY\n\t\t\t}\n\t\t\treturn [id, point.rot(pageRotation).add(pagePoint)]\n\t\t})\n\t)\n}\n\n/**\n * Get all of the available note adjacent positions, excluding the selected shapes.\n *\n * @param editor - The editor instance.\n * @param rotation - The rotation of the note shape.\n * @param extraHeight - The extra height to add to the top position above the note shape (ie the growY of the dragging shape).\n *\n * @internal */\nexport function getAvailableNoteAdjacentPositions(\n\teditor: Editor,\n\trotation: number,\n\textraHeight: number\n) {\n\tconst selectedShapeIds = new Set(editor.getSelectedShapeIds())\n\tconst minSize = (NOTE_SIZE + ADJACENT_NOTE_MARGIN + extraHeight) ** 2\n\tconst allCenters = new Map<TLNoteShape, Vec>()\n\tconst positions: (Vec | undefined)[] = []\n\n\t// Get all the positions that are adjacent to the selected note shapes\n\tfor (const shape of editor.getCurrentPageShapes()) {\n\t\tif (!editor.isShapeOfType<TLNoteShape>(shape, 'note') || selectedShapeIds.has(shape.id)) {\n\t\t\tcontinue\n\t\t}\n\n\t\tconst transform = editor.getShapePageTransform(shape.id)!\n\n\t\t// If the note has a different rotation, we can't use its adjacent positions\n\t\tif (rotation !== transform.rotation()) continue\n\n\t\t// Save the unselected note shape's center\n\t\tallCenters.set(shape, editor.getShapePageBounds(shape)!.center)\n\n\t\t// And push its position to the positions array\n\t\tpositions.push(\n\t\t\t...Object.values(\n\t\t\t\tgetNoteAdjacentPositions(transform.point(), rotation, shape.props.growY, extraHeight)\n\t\t\t)\n\t\t)\n\t}\n\n\t// Remove positions that are inside of another note shape\n\tconst len = positions.length\n\tlet position: Vec | undefined\n\tfor (const [shape, center] of allCenters) {\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tposition = positions[i]\n\t\t\tif (!position) continue\n\t\t\tif (Vec.Dist2(center, position) > minSize) continue\n\t\t\tif (editor.isPointInShape(shape, position)) {\n\t\t\t\tpositions[i] = undefined\n\t\t\t}\n\t\t}\n\t}\n\n\treturn compact(positions)\n}\n\n/**\n * For a particular adjacent note position, get the shape in that position or create a new one.\n *\n * @param editor - The editor instance.\n * @param shape - The note shape to create or select.\n * @param center - The center of the note shape.\n * @param pageRotation - The rotation of the note shape on the page.\n * @param forceNew - Whether to force the creation of a new note shape.\n *\n * @internal */\nexport function getNoteShapeForAdjacentPosition(\n\teditor: Editor,\n\tshape: TLNoteShape,\n\tcenter: Vec,\n\tpageRotation: number,\n\tforceNew = false\n) {\n\t// There might already be a note in that position! If there is, we'll\n\t// select the next note and switch focus to it. If there's not, then\n\t// we'll create a new note in that position.\n\n\tlet nextNote: TLShape | undefined\n\n\t// Check the center of where a new note would be\n\t// Start from the top of the stack, and work our way down\n\tconst allShapesOnPage = editor.getCurrentPageShapesSorted()\n\n\tconst minDistance = NOTE_SIZE + ADJACENT_NOTE_MARGIN ** 2\n\n\tfor (let i = allShapesOnPage.length - 1; i >= 0; i--) {\n\t\tconst otherNote = allShapesOnPage[i]\n\t\tif (otherNote.type === 'note' && otherNote.id !== shape.id) {\n\t\t\tconst otherBounds = editor.getShapePageBounds(otherNote)\n\t\t\tif (\n\t\t\t\totherBounds &&\n\t\t\t\tVec.Dist2(otherBounds.center, center) < minDistance &&\n\t\t\t\teditor.isPointInShape(otherNote, center)\n\t\t\t) {\n\t\t\t\tnextNote = otherNote\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\teditor.complete()\n\n\t// If we didn't find any in that position, then create a new one\n\tif (!nextNote || forceNew) {\n\t\teditor.mark('creating note shape')\n\t\tconst id = createShapeId()\n\n\t\t// We create it at the center first, so that it becomes\n\t\t//  the child of whatever parent was at that center\n\t\teditor.createShape({\n\t\t\tid,\n\t\t\ttype: 'note',\n\t\t\tx: center.x,\n\t\t\ty: center.y,\n\t\t\trotation: pageRotation,\n\t\t\topacity: shape.opacity,\n\t\t\tprops: {\n\t\t\t\t// Use the props of the shape we're cloning\n\t\t\t\t...shape.props,\n\t\t\t\t// ...except for these values, which should reset to their defaults\n\t\t\t\ttext: '',\n\t\t\t\tgrowY: 0,\n\t\t\t\tfontSizeAdjustment: 0,\n\t\t\t\turl: '',\n\t\t\t},\n\t\t})\n\n\t\t// Now we need to correct its location within its new parent\n\n\t\tconst createdShape = editor.getShape(id)!\n\n\t\t// We need to put the page point in the same coordinate\n\t\t// space as the newly created shape (i.e its parent's space)\n\t\tconst topLeft = editor.getPointInParentSpace(\n\t\t\tcreatedShape,\n\t\t\tVec.Sub(center, Vec.Rot(NOTE_CENTER_OFFSET, pageRotation))\n\t\t)\n\n\t\teditor.updateShape({\n\t\t\tid,\n\t\t\ttype: 'note',\n\t\t\tx: topLeft.x,\n\t\t\ty: topLeft.y,\n\t\t})\n\n\t\tnextNote = editor.getShape(id)!\n\t}\n\n\tzoomToShapeIfOffscreen(editor)\n\treturn nextNote\n}\n"],
  "mappings": "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",
  "names": []
}
